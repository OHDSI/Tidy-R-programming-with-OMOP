# Identifying patient characteristics {#sec-adding_features}

For this chapter, we'll again use our example COVID-19 dataset.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(omock)
library(PatientProfiles)
library(ggplot2)
library(omopgenerics) # TODO https://github.com/OHDSI/omock/issues/189 
```

```{r}
cdm <- mockCdmFromDataset(datasetName = "synthea-covid19-10k", source = "duckdb")
```

As part of an analysis, we almost always have a need to identify certain characteristics related to the individuals in our data. These characteristics might be time-invariant (i.e. a characteristic that does not change as time passes and a person ages) or time-varying.[^adding_features-1]

[^adding_features-1]: In some datasets, characteristics that could conceptually be considered as time-varying are encoded as time-invariant. One example of the latter is that in some cases an individual may be associated with a particular socioeconomic status or nationality that for the purposes of the data is treated as time-invariant.

## Adding specific demographics

The [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) package makes it easy for us to add demographic information to tables in the OMOP CDM. Like the [`CDMConnector`](https://darwin-eu.github.io/CDMConnector/) package we've seen previously, the fact that the structure of the OMOP CDM is known allows the [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) package to abstract away some common data manipulations required to do research with patient-level data.[^adding_features-2]

[^adding_features-2]: Although these manipulations can seem quite simple on the face of it, their implementation across different database platforms with different data granularity (for example, whether day of birth has been filled in for all patients or not) presents challenges that the [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) package solves for us.

Let’s say we’re interested in individuals’ age and sex at the time of COVID-19 diagnosis. We can add these variables to the table as follows (noting that, since age is time-varying, we need to specify the date relative to which it should be calculated).

```{r}
cdm$condition_occurrence <- cdm$condition_occurrence |> 
  addSex() |> 
  addAge(indexDate = "condition_start_date")

cdm$condition_occurrence |> 
  glimpse()
```

We have now added two variables containing values for age and sex.

```{r}
cdm$condition_occurrence |> 
  glimpse()
```

With these now added, it is straightforward to calculate the mean age at condition start date by sex or even plot the distribution of age at diagnosis by sex.

```{r}
cdm$condition_occurrence |>
  group_by(sex) |>
  summarise(mean_age = mean(age, na.rm=TRUE)) |> 
  collect()
```

```{r}
cdm$condition_occurrence |>
  select("person_id", "age", "sex") |> 
  collect()  |>
  ggplot(aes(fill = sex)) +
  facet_grid(sex ~ .) +
  geom_histogram(aes(age), colour = "black", binwidth = 5) +
  theme_bw() +
  theme(legend.position = "none")
```

::: {.callout-note collapse="true"}
### Show query

```{r}
cdm$condition_occurrence |> 
  addSexQuery() |> 
  show_query()
```

The difference between [`addSexQuery()`](https://darwin-eu.github.io/PatientProfiles/reference/addSexQuery.html) and [`addSex()`](https://darwin-eu.github.io/PatientProfiles/reference/addSex.html) is explained in the next tip chunk.
:::

## Adding multiple demographics simultaneously

We've now seen individual functions from [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) that add specific patient characteristics such as age and sex. The package also includes functions to add other characteristics, such as the number of days of prior observation in the database (rather unimaginatively named [`addPriorObservation()`](https://darwin-eu.github.io/PatientProfiles/reference/addPriorObservation.html)). In addition to these individual functions, the package also provides a more general function that retrieves all of these characteristics at the same time.[^adding_features-3]

[^adding_features-3]: This function also provides a more time-efficient method than getting the characteristics one by one. This is because these characteristics are all derived from the OMOP CDM person and observation period tables, and so can be identified simultaneously.

```{r}
cdm$drug_exposure <- cdm$drug_exposure |> 
  addDemographics(
    indexDate = "drug_exposure_start_date",
    age = TRUE,
    sex = TRUE,
    priorObservation = TRUE,
    futureObservation = TRUE,
    dateOfBirth = TRUE
  )

cdm$drug_exposure |> 
  glimpse()
```

With these characteristics added, we can now calculate mean age, prior observation (the number of days have passed since each individual's most recent observation start date), and future observation (the number of days until the individual's nearest observation end date) at drug exposure start date, stratified by sex.

```{r}
cdm$drug_exposure |>
  group_by(sex) |>
  summarise(mean_age = mean(age, na.rm=TRUE),
            mean_prior_observation = mean(prior_observation, na.rm=TRUE),
            mean_future_observation = mean(future_observation, na.rm=TRUE)) |> 
  collect()
```

::: {.callout-tip collapse="true"}
### Returning a query from [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) rather than the result

In the above examples, the functions from [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) execute queries and write the results to a table in the database (either a temporary table if no name is provided when calling the function, or a permanent table). We might instead want to just get the underlying query back so that we have more control over how and when the query is executed.

```{r, echo = TRUE}
cdm$visit_occurrence |> 
  addSex() |> 
  filter(sex == "Male") |> 
  show_query()
```

```{r, echo = TRUE}
cdm$visit_occurrence |> 
  addSex(name = "my_new_table") |> 
  filter(sex == "Male") |> 
  show_query()
```

```{r, echo = TRUE}
cdm$visit_occurrence |> 
  addSexQuery() |> 
  filter(sex == "Male") |> 
  show_query()
```

Query functions can be useful in some contexts where you don't want to generate multiple temporary tables or do not want to lose indexes of a certain table, but they can also generate large queries that could result in low performance.
:::

## Creating categories

When adding age, either via [addAge](https://darwin-eu.github.io/PatientProfiles/reference/addAge.html) or [addDemographics](https://darwin-eu.github.io/PatientProfiles/reference/addDemographics.html), we can also include an additional variable that groups individuals into age categories. These age groups must be specified in a list of vectors, each of which containing the lower and upper bounds.

```{r}
cdm$visit_occurrence <- cdm$visit_occurrence |>
  addAge(
    indexDate = "visit_start_date",
    ageGroup = list(c(0,17), c(18, 64), c(65, Inf))
  )

cdm$visit_occurrence |> 
  # data quality issues with our synthetic data means we have 
  # some negative ages so will drop these
  filter(age >= 0) |> 
  group_by(age_group) |> 
  tally() |> 
  collect() |> 
  ggplot() + 
  geom_col(aes(x = age_group, y = n, fill = age_group)) + 
  theme_bw()
```

::: {.callout-tip collapse="true"}
### Naming age groups

As we have seen, by default the age groups are named according to their lower and upper bounds (‘0 to 17’, ‘18 to 64’, and ‘65 or above’). However, we can customise these labels by assigning names to the list of age groups:

```{r}
cdm$condition_occurrence |>
  addAgeQuery(
    indexDate = "condition_start_date",
    ageGroup = list("pediatric" = c(0,17), "adult" = c(18, Inf))
  ) |>
  filter(age >= 0) |> 
  group_by(age_group) |> 
  tally() |> 
  collect() |> 
  ggplot() + 
  geom_col(aes(x = age_group, y = n, fill = age_group)) + 
  theme_bw()
```

If you take a close look at the documentation of the function, you’ll see that it also allows you to add multiple age groups and to control the name of the new column, which by default is ‘age_group’.
:::

[`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) also provides a more general function for adding categories. Can you guess its name? That's right, we have [`addCategories()`](https://darwin-eu.github.io/PatientProfiles/reference/addCategories.html) for this.

```{r}
cdm$condition_occurrence |>
  addPriorObservation(indexDate = "condition_start_date") |>
  addCategories(
    variable = "prior_observation",
    categories = list("prior_observation_group" = list(
      c(0, 364), c(365, Inf)  
    ))
  ) |> 
  glimpse()
```

## Adding custom variables

While [`PatientProfiles`](https://darwin-eu.github.io/PatientProfiles/) provides a range of functions that can help you add characteristics of interest, you may also want to add other features. Obviously, we can't cover here all possible custom characteristics you may wish to add. However, two common groups of custom features are those that are derived from other variables in the same table and others that are taken from other tables and joined to our particular table of interest.

In the first case, where we want to add a new variable derived from existing variables within our table, we'll typically use [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html) (from the [`dplyr`](https://dplyr.tidyverse.org) package). For example, perhaps we just want to add a new variable to our observation period table that contains the year of each individual’s observation period start date. This is rather straightforward.

```{r}
cdm$observation_period <- cdm$observation_period |> 
  mutate(observation_period_start_year = get_year(observation_period_start_date))

cdm$observation_period |> 
  glimpse()
```

The second case is usually a more complex task, as adding a new variable involves joining to some other table following a certain logic. This table may have been created by some intermediate query that we wrote to derive the variable of interest. For example, let's say we want to add the number of condition occurrence records for each individual to the person table (remember that we saw how to calculate this in the previous chapter). To do this, we will need to perform a join between the person and condition occurrence tables (as some people might not have any records in the condition occurrence table). Here we'll create a table containing just the information we're interested in and compute it to a temporary table.

```{r}
condition_summary <- cdm$person |> 
  select("person_id") |> 
  left_join(
    cdm$condition_occurrence |> 
      group_by(person_id) |> 
      count(name = "condition_occurrence_records"),
    by="person_id"
  ) |> 
  select("person_id", "condition_occurrence_records") |> 
  mutate(condition_occurrence_records = coalesce(condition_occurrence_records, 0)) |>
  compute()

condition_summary |> 
  glimpse()
```

We can see what goes on behind the scenes by viewing the associated SQL.

```{r}
cdm$person |> 
  select("person_id") |> 
  left_join(
    cdm$condition_occurrence |> 
      group_by(person_id) |> 
      count(name = "condition_occurrence_records"),
    by="person_id"
  ) |> 
  select("person_id", "condition_occurrence_records") |> 
  mutate(condition_occurrence_records = coalesce(condition_occurrence_records, 0)) |>
  show_query()
```

::: {.callout-tip collapse="true"}
### Taking care with joins

When adding variables through joins we need to pay particular attention to the dimensions of the resulting table. While sometimes we may want to have additional rows added as well as new columns, this is often not desired. For example, if we have a table with one row per person, performing a left join to another table containing multiple rows per person will result in multiple rows per person in the output.

Examples where to be careful include when joining to the observation period table, as individuals can have multiple observation periods, and when working with cohorts (which are the focus of the next chapter) as individuals can also enter the same study cohort multiple times.

Just to underline how problematic joins can become if we don't take care, here we join the condition occurrence table and the drug exposure table, both of which have multiple records per person. Even with our small synthetic dataset, this produces an extremely large table. When working with real patient data, which is oftentimes much, much larger, this would be extremely problematic (and would unlikely be needed to answer any research question). In other words, don't try this at home!

```{r}
cdm$condition_occurrence |> 
  tally()
cdm$drug_exposure |> 
  tally()
cdm$condition_occurrence |> 
  select(person_id, condition_start_date) |> 
  left_join(
    cdm$drug_exposure |> 
      select(person_id, drug_exposure_start_date), 
    by = "person_id"
  ) |> 
  tally()
```
:::

## Disconnecting

Once we have finished our analysis we can close our connection to the database behind our cdm reference.

```{r}
cdmDisconnect(cdm) 
```

## Further reading

-   Català M, Guo Y, Du M, Lopez-Guell K, Burn E, Mercade-Besora N (2025). *PatientProfiles: Identify Characteristics of Patients in the OMOP Common Data Model*. R package version 1.4.3, <https://darwin-eu.github.io/PatientProfiles/>.
