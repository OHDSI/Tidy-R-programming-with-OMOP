# Building analytic pipelines for a data model {#sec-data_model}

In the previous chapters, we've seen that after connecting to a database, we can create references to the various tables we're interested in and write custom analytic code to query them. However, if we are working with the same database over and over again, we might want to build some tooling for tasks we often perform.

To see how we can develop a data model with associated methods and functions, we will use the Lahman baseball data. The data is stored across various related tables.

![Lahman's Baseball Dabatase schema from <https://cdalzell.github.io/Lahman/>.](../images/lahman.jpg){#fig-lahman .lightbox}

## Defining a data model

```{r, message=FALSE, warning=FALSE, echo = TRUE}
library(duckdb)
library(dplyr)
library(tidyr)
library(purrr)
library(cli)
library(dbplyr)
library(Lahman)

con <- dbConnect(drv = duckdb())
copy_lahman(con = con)
```

::: {.callout-note collapse="true"}
### copy_lahman

The `copy_lahman()` function inserts all the different tables in the connection. It works in the same way as we have done before with the for loop and the `dbWriteTable()` function.

See that there are 28 new tables inserted in our DuckDB database:

```{r}
dbListTables(conn = con)
```
:::

Instead of manually creating references for each one of the tables (so we can access them easily), we will write a function to create a single reference to the Lahman data.

```{r, message=FALSE, warning=FALSE, echo = TRUE}
lahmanFromCon <- function(con) {
  lahmanRef <- set_names(c(
    "AllstarFull", "Appearances", "AwardsManagers", "AwardsPlayers", "AwardsManagers",
    "AwardsShareManagers", "Batting", "BattingPost", "CollegePlaying", "Fielding",
    "FieldingOF", "FieldingOFsplit", "FieldingPost", "HallOfFame", "HomeGames",
    "LahmanData", "Managers", "ManagersHalf", "Parks", "People", "Pitching",
    "PitchingPost", "Salaries", "Schools", "SeriesPost", "Teams", "TeamsFranchises",
    "TeamsHalf"
  ))
  
  lahmanRef <- map(lahmanRef, \(x) tbl(src = con, from = x))
  
  class(lahmanRef) <- c("lahman_ref", class(lahmanRef))
  return(lahmanRef)
}
```

With this function we can now easily get references to all our Lahman tables in one go using our `lahmanFromCon()` function.

```{r, message=FALSE, warning=FALSE}
lahman <- lahmanFromCon(con = con)

lahman$People |>
  glimpse()
```

::: {.callout-note collapse="true"}
### The dm package

In this chapter we will be creating a bespoke data model for our database. This approach can be further extended using the [`dm`](https://dm.cynkra.com/) package, which also provides various helpful functions for creating a data model and working with it.

Similar to above, we can use [`dm()`](https://dm.cynkra.com/reference/dm.html) to create a single object to access our database tables.

```{r, message=FALSE, warning=FALSE}
library(dm)
lahman_dm <- dm(batting = tbl(con, "Batting"), people = tbl(con, "People"))
lahman_dm
```

Using this approach, we can make use of various utility functions. For example here we specify [primary and foreign keys](https://www.geeksforgeeks.org/dbms/difference-between-primary-key-and-foreign-key/) and then check that the key constraints are satisfied.

```{r, echo=TRUE}
lahman_dm <- lahman_dm |>
  dm_add_pk(table = "people", columns = "playerID") |>
  dm_add_fk(table = "batting", columns = "playerID", ref_table = "people") 

lahman_dm

dm_examine_constraints(.dm = lahman_dm)
```

For more information on the dm package see <https://dm.cynkra.com/index.html>
:::

## Creating functions for the data model

Given that we know the structure of the data, we can build a set of functions tailored to the Lahman data model to simplify data analyses.

Let's start by creating a simple function that returns the teams each player has played for. We can see that the code we use follows on from the last couple of chapters.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
getTeams <- function(lahman, name = "Barry Bonds") {
  lahman$Batting |>
    inner_join(
      lahman$People |>
        mutate(full_name = paste0(nameFirst, " ", nameLast)) |>
        filter(full_name %in% name) |>
        select("playerID"),
      by = "playerID"
    ) |>
    distinct(teamID, yearID) |>
    left_join(
      lahman$Teams, 
      by = c("teamID", "yearID")) |>
    distinct(name)
}
```

Now we can easily get which teams a player has represented. We can see how changing the player name changes the SQL that is run behind the scenes.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
getTeams(lahman = lahman, name = "Babe Ruth")
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
getTeams(lahman = lahman, name = "Babe Ruth") |>
  show_query()
```
:::

```{r, message = FALSE, warning = FALSE, echo = TRUE}
getTeams(lahman = lahman, name = "Barry Bonds")
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
getTeams(lahman = lahman, name = "Barry Bonds") |>
  show_query()
```
:::

::: {.callout-tip collapse="true"}
### Choosing the right time to collect data into R

The function [`collect()`](https://dplyr.tidyverse.org/reference/compute.html) brings data out of the database and into R. When working with large datasets, as is often the case when interacting with a database, we typically want to keep as much computation as possible on the database side. In the case of our `getTeams()` function, for example, everything is done on the database side. Collecting the result will bring the result of the teams the person played for out of the database. In this case, we could also use [`pull()`](https://dplyr.tidyverse.org/reference/pull.html) to get our result out as a vector rather than a data frame.

```{r, message=FALSE, warning=FALSE}
getTeams(lahman = lahman, name = "Barry Bonds") |>
  collect()

getTeams(lahman = lahman, name = "Barry Bonds") |>
  pull()
```

However, in other cases we may need to collect the data to perform analyses that can not be done in SQL. This might be the case for plotting or for other analytic steps(i.e., fitting statistical models). In such cases, it is important to only bring out the data that we need (as our local computer will typically have far less memory available than the database system).
:::

Similarly, we can make a function to add a player's year of birth to another Lahman table.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
addBirthCountry <- function(x){
  x |> 
    left_join(
      lahman$People |> 
        select("playerID", "birthCountry"),
      by = "playerID"
    )
}
```

```{r, message = FALSE, warning = FALSE, echo = TRUE}
lahman$Batting |>
  addBirthCountry()
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Batting |>
  addBirthCountry() |>
  show_query()
```
:::

```{r, message = FALSE, warning = FALSE, echo = TRUE}
lahman$Pitching |>
  addBirthCountry()
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Pitching |>
  addBirthCountry() |>
  show_query()
```
:::

We can then use our `addBirthCountry()` function as part of a larger query to summarise and plot the proportion of players from each country over time (based on their presence in the batting table). 

```{r, message = FALSE, warning = FALSE, echo = TRUE}
plot_data <- lahman$Batting |>
  select("playerID", "yearID") |> 
  addBirthCountry() |>
  filter(yearID > 1960) |> 
  mutate(birthCountry = case_when(
    birthCountry == "USA" ~ "USA",
    birthCountry == "D.R." ~ "Dominican Republic",
    birthCountry == "Venezuela" ~ "Venezuela",
    birthCountry == "P.R." ~ "Puerto Rico ",
    birthCountry == "Cuba" ~ "Cuba",
    birthCountry == "CAN" ~ "Canada",
    birthCountry == "Mexico" ~ "Mexico",
    .default = "Other"
  )) |> 
  group_by(yearID, birthCountry) |>
  summarise(n = n(), .groups = "drop") |> 
  group_by(yearID) |>
  mutate(percentage = n / sum(n) * 100) |> 
  ungroup() |> 
  collect()
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Batting |>
  select(playerID, yearID) |> 
  addBirthCountry() |>
  filter(yearID > 1960) |> 
  mutate(birthCountry = case_when(
    birthCountry == "USA" ~ "USA",
    birthCountry == "D.R." ~ "Dominican Republic",
    birthCountry == "Venezuela" ~ "Venezuela",
    birthCountry == "P.R." ~ "Puerto Rico ",
    birthCountry == "Cuba" ~ "Cuba",
    birthCountry == "CAN" ~ "Canada",
    birthCountry == "Mexico" ~ "Mexico",
    .default = "Other"
  )) |> 
  group_by(yearID, birthCountry) |>
  summarise(n = n(), .groups = "drop") |> 
  group_by(yearID) |>
  mutate(percentage = n / sum(n) * 100) |> 
  ungroup() |> 
  show_query()
```
:::

```{r, message = FALSE, warning = FALSE, echo = TRUE}
library(ggplot2)
plot_data |> 
  ggplot() +
  geom_col(
    mapping = aes(yearID, percentage, fill = birthCountry), 
    width = 1
  ) + 
  theme_minimal() + 
  theme(
    legend.title = element_blank(), 
    legend.position = "top"
  )
```

::: {.callout-note collapse="true"}
### Defining methods for the data model

As part of our `lahmanFromCon()` function, our data model object has the class "lahman_ref". Therefore, apart from creating user-friendly functions to work with our Lahman data model, we can also define methods for this object.

```{r, message=FALSE, warning=FALSE}
class(lahman)
```

With this we can make some specific methods for a "lahman_ref" object. For example, we can define a print method like so:

```{r, message=FALSE, warning=FALSE}
print.lahman_ref <- function(x, ...) {
  len <- length(names(x))
  cli_h1("# Lahman reference - {len} tables")
  cli_li(paste("{.strong tables:}", paste(names(x), collapse = ", ")))
  invisible(x)
}
```

Now we can see a summary of our Lahman data model when we print the object.

```{r, echo = TRUE}
lahman
```

And we can see that this print is being done by the method we defined.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
library(sloop)
s3_dispatch(print(lahman))
```
:::

## Building efficient analytic pipelines

### The risk of "clean" R code

Following on from the above approach, we might think it is a good idea to make another function `addBirthYear()`. We can then use it along with our `addBirthCountry()` to get a summarised average salary by birth country and birth year.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
addBirthYear <- function(lahmanTbl){
  lahmanTbl |> 
    left_join(
      lahman$People |> 
        select("playerID", "birthYear"),
      by = "playerID"
    )
}

lahman$Salaries |> 
  addBirthCountry() |> 
  addBirthYear() |> 
  group_by(birthCountry, birthYear) |>
  summarise(average_salary = mean(salary), .groups = "drop")
```

Although the R code looks fine, when we look at the SQL we can see that our query has two joins to the People table. One join gets information on the birth country and the other on the birth year.

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Salaries |> 
  addBirthCountry() |> 
  addBirthYear() |> 
  group_by(birthCountry, birthYear) |>
  summarise(average_salary = mean(salary), .groups = "drop") |> 
  show_query()
```
:::

To improve the performance of the code, we can build a single function to get simultaneously the birth country and birth year, so only one join is done.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
addCharacteristics <- function(lahmanTbl){
  lahmanTbl |> 
    left_join(
      lahman$People |> 
        select("playerID", "birthYear", "birthCountry"),
      by = "playerID"
    )
}

lahman$Salaries |> 
  addCharacteristics() |> 
  group_by(birthCountry, birthYear) |>
  summarise(average_salary = mean(salary), .groups = "drop")
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Salaries |> 
  addCharacteristics() |> 
  group_by(birthCountry, birthYear) |>
  summarise(average_salary = mean(salary), .groups = "drop") |> 
  show_query()
```
:::

This query produces the same result but is simpler than the previous one, thus reducing the computational cost of the analysis. This shows the importance of being aware of the SQL code being executed when working in R with databases.

### Piping and SQL

Piping functions has little impact on performance when using R with data in memory. However, when working with a database, the SQL generated will differ when using multiple function calls (with a separate operation specified in each) instead of multiple operations within a single function call.

For example, a single mutate function creating two new variables would generate the below SQL.

```{r, echo = TRUE}
lahman$People |> 
  mutate(
    birthDatePlus1 = add_years(x = birthDate, n = 1L),
    birthDatePlus10 = add_years(x = birthDate, n = 10L)
  ) |> 
  select("playerID", "birthDatePlus1", "birthDatePlus10") |> 
  show_query()
```

Whereas the SQL will be different if these were created using multiple mutate calls (with now one being created in a sub-query).

```{r, echo = TRUE}
lahman$People |> 
  mutate(birthDatePlus1 = add_years(x = birthDate, n = 1L)) |> 
  mutate(birthDatePlus10 = add_years(x = birthDate, n = 10L)) |> 
  select("playerID", "birthDatePlus1", "birthDatePlus10") |> 
  show_query()
```

### Computing intermediate queries

Let's now summarise home runs (Batting table) and strike outs (Pitching table) by college player and their birth year. We can do this like so:

```{r, echo = TRUE}
players_with_college <- lahman$People |> 
  select("playerID", "birthYear") |> 
  inner_join(
    lahman$CollegePlaying |> 
      filter(!is.na(schoolID)) |> 
      distinct(playerID, schoolID),
    by = "playerID"
  )

lahman$Batting |> 
  left_join(
    players_with_college,
    by = "playerID"
  ) |> 
  group_by(schoolID, birthYear) |>
  summarise(home_runs = sum(H, na.rm = TRUE), .groups = "drop") |> 
  collect()

lahman$Pitching |> 
  left_join(
    players_with_college, 
    by = "playerID"
  ) |> 
  group_by(schoolID, birthYear) |>
  summarise(strike_outs = sum(SO, na.rm = TRUE), .groups = "drop")|> 
  collect()
```

If we look at the SQL code we will realise that there is code duplication, because as part of each full query, we have run our players_with_college query.

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Batting |> 
  left_join(players_with_college, by = "playerID") |> 
  group_by(schoolID, birthYear) |>
  summarise(home_runs = sum(H, na.rm = TRUE), .groups = "drop") |> 
  show_query()

lahman$Pitching |> 
  left_join(players_with_college, by = "playerID") |>
  group_by(schoolID, birthYear) |>
  summarise(strike_outs = sum(SO, na.rm = TRUE), .groups = "drop") |> 
  show_query()
```
:::

To avoid this, we can make use of the [`compute()`](https://dplyr.tidyverse.org/reference/compute.html) function to force the computation of the players_with_college query to a temporary table in the database.

```{r, echo = TRUE}
players_with_college <- players_with_college |> 
  compute()
```

Now we have a temporary table with the result of our players_with_college query, and we can use this in both of our aggregation queries.

```{r, echo = TRUE}
players_with_college |> 
  show_query()
```

```{r, echo = TRUE}
lahman$Batting |> 
  left_join(players_with_college, by = "playerID") |> 
  group_by(schoolID, birthYear) |>
  summarise(home_runs = sum(H, na.rm = TRUE), .groups = "drop") |> 
  collect()

lahman$Pitching |> 
  left_join(players_with_college, by = "playerID") |> 
  group_by(schoolID, birthYear) |>
  summarise(strike_outs = sum(SO, na.rm = TRUE), .groups = "drop") |> 
  collect()
```

::: {.callout-note collapse="true"}
### Show query

```{r, message=FALSE, warning=FALSE, echo=FALSE}
lahman$Batting |> 
  left_join(players_with_college, by = "playerID") |>
  group_by(schoolID, birthYear) |>
  summarise(home_runs = sum(H, na.rm = TRUE), .groups = "drop") |> 
  show_query()

lahman$Pitching |> 
  left_join(players_with_college, by = "playerID") |> 
  group_by(schoolID, birthYear) |>
  summarise(strike_outs = sum(SO, na.rm = TRUE), .groups = "drop") |> 
  show_query()
```
:::

In this example, the SQL code of the intermediate table, players_with_college, was quite simple. However, in some cases, the SQL associated code can become very complicated and unmanageable, resulting with inefficient code. Therefore, although we do not want to overuse computation of intermediate queries, it is often useful when creating our analytic pipelines.

::: {.callout-note collapse="true"}
### Indexes

Some SQL dialects use indexes for more efficient 'joins' performance. Briefly speaking, indexes store the location of the different values of a column. Every time that you create a new table with [`compute()`](https://dplyr.tidyverse.org/reference/compute.html), the indexes will not be carried over. Hence, if you want your new table to keep some indexes, you will have to add them manually. That is why sometimes it will not be more efficient to add a [`compute()`](https://dplyr.tidyverse.org/reference/compute.html) in between, because the new table generated will not have the indexes that make your query to be executed faster.
:::

## Disconnecting from the database

Now that we have reached the end of this example, we can close our connection to the database.

```{r}
dbDisconnect(conn = con)
```
