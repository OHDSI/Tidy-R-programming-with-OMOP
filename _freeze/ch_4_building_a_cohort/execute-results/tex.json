{
  "hash": "c02997d787150f58768e5bf2b144c279",
  "result": {
    "markdown": "---\noutput: html_document\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# Adding cohorts to the CDM\n\n## Cohort definitions\n\nWhen performing research with the OMOP common data model we often want to identify groups of individuals who share some set of characteristics. The criteria for including individuals can range from the seemingly simple (e.g. people diagnosed with asthma) to the much more complicated (e.g. adults diagnosed with asthma who had a year of prior observation time in the database prior to their diagnosis, had no prior history of chronic obstructive pulmonary disease, and no history of use of short-acting beta-agonists). The set of people we identify are cohorts, and the OMOP CDM has a specific structure by which they can be represented, with a cohort table having four required fields: 1) cohort definition id (a unique identifier for each cohort), subject id (a foreign key to the subject in the cohort - typically referring to records in the person table), cohort start date, and cohort end date.\n\nCohorts can be defined using entirely bespoke code (so long as the output fits the cohort table specification). However because cohort definitions often follow a similar logic, tools have also be developed to facilitate cohort creation. In particular, [ATLAS](https://atlas-demo.ohdsi.org) provides a graphical user interface which can be used to create cohort definitions that are expressed as JSON which can subsequently be rendered to SQL. The Capr R package, used below, provides a means of defining the JSON via R code instead.\n\n## Defining cohorts programmatically\n\nWe can define a cohort programmatically using the Capr package. In addition we the CodelistGenerator package can be used to help find the codes to use in our cohort definitions.\n\nLet´s load the required packages and connect to the Eunomia data again.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(CDMConnector)\nlibrary(dplyr)\nlibrary(Capr)\nlibrary(CodelistGenerator)\n\ncon <- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nDownload completed!\n```\n:::\n\n```{.r .cell-code}\ncdm <- CDMConnector::cdm_from_con(\n  con = con,\n  cdm_schema = \"main\",\n  write_schema = \"main\"\n)\n```\n:::\n\n\n\nSay we want to create a cohort of people with a gastrointestinal hemorrhage. We´ll start by getting the code that represents \"gastrointestinal hemorrhage\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngibleed_codes <- getCandidateCodes(cdm = cdm, \n                  keywords = \"gastrointestinal hemorrhage\",\n                  domains = \"condition\",\n                  exactMatch = TRUE,\n                  includeDescendants = FALSE)\ngibleed_codes %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 6\n$ concept_id       <int> 192671\n$ concept_name     <chr> \"Gastrointestinal hemorrhage\"\n$ domain_id        <chr> \"condition\"\n$ concept_class_id <chr> \"clinical finding\"\n$ vocabulary_id    <chr> \"snomed\"\n$ found_from       <chr> \"From initial search\"\n```\n:::\n\n```{.r .cell-code}\ngibleed_concept_set <- cs(descendants(gibleed_codes$concept_id))\n```\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Finding appropriate codes\n\nThe above gives the impression that identifying concepts that represent a particular clinical idea is straightforward. In practice, however, this is rarely the case. Identifying the codes that could represent a condition and then choosing which does though is typically a time consuming task .....\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetCandidateCodes(cdm = cdm, \n                  keywords = \"fracture\",\n                  domains = \"condition\",\n                  includeDescendants = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 x 6\n  concept_id concept_name    domain_id concept_class_id vocabulary_id found_from\n       <int> <chr>           <chr>     <chr>            <chr>         <chr>     \n1    4048695 Fracture of ve~ condition clinical finding snomed        From init~\n2    4142905 Fracture of rib condition clinical finding snomed        From init~\n3    4278672 Fracture of fo~ condition clinical finding snomed        From init~\n4    4237458 Fracture of cl~ condition clinical finding snomed        From init~\n5    4230399 Closed fractur~ condition clinical finding snomed        From init~\n6   40480160 Pathological f~ condition clinical finding snomed        From init~\n7    4066995 Fracture of ve~ condition clinical finding snomed        From init~\n8    4059173 Fracture of an~ condition clinical finding snomed        From init~\n9    4134304 Fracture sublu~ condition clinical finding snomed        From init~\n```\n:::\n:::\n\n\n:::\n\nOnce we´ve identified our codes we´ll create a concept set that includes this code or any of its descendants.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngibleed_concept_set <- cs(descendants(gibleed_codes$concept_id))\n```\n:::\n\n\n\nWe can now use this concept set in a cohort definition. We´ll look for anyone with a correspong record in the condition occurrence table. We´ll also require that this is their first such record.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nentry_criteria <- entry(\n    condition(gibleed_concept_set),\n    primaryCriteriaLimit = \"First\"\n  )\n\ngibleed_cohort_definition <- cohort(entry = entry_criteria)\n```\n:::\n\n\n\nWe could though make things a little more complicated. What if we wanted to exclude anyone with rheumatoid arthritis (regardless of when they were diagnosed). To do this we´ll first need to create another concept set, this time for rheumatoid arthritis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrheumatoid_arthritis_codes <- getCandidateCodes(cdm = cdm, \n                  keywords = \"rheumatoid arthritis\",\n                  domains = \"condition\",\n                  exactMatch = TRUE,\n                  includeDescendants = FALSE)\nrheumatoid_arthritis_codes %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 6\n$ concept_id       <int> 80809\n$ concept_name     <chr> \"Rheumatoid arthritis\"\n$ domain_id        <chr> \"condition\"\n$ concept_class_id <chr> \"clinical finding\"\n$ vocabulary_id    <chr> \"snomed\"\n$ found_from       <chr> \"From initial search\"\n```\n:::\n\n```{.r .cell-code}\nrheumatoid_arthritis_concept_set <- cs(descendants(\n  rheumatoid_arthritis_codes$concept_id))\n```\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## JSON representation of a concept set\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(as.json(gibleed_concept_set))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n  \"items\": [\n    {\n      \"concept\": {\n        \"CONCEPT_ID\": 192671,\n        \"CONCEPT_NAME\": \"\",\n        \"STANDARD_CONCEPT\": \"\",\n        \"STANDARD_CONCEPT_CAPTION\": \"\",\n        \"INVALID_REASON\": \"\",\n        \"INVALID_REASON_CAPTION\": \"\",\n        \"CONCEPT_CODE\": \"\",\n        \"DOMAIN_ID\": \"\",\n        \"VOCABULARY_ID\": \"\",\n        \"CONCEPT_CLASS_ID\": \"\"\n      },\n      \"isExcluded\": false,\n      \"includeDescendants\": true,\n      \"includeMapped\": false\n    }\n  ]\n}\n```\n:::\n\n```{.r .cell-code}\ncat(as.json(rheumatoid_arthritis_concept_set))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n  \"items\": [\n    {\n      \"concept\": {\n        \"CONCEPT_ID\": 80809,\n        \"CONCEPT_NAME\": \"\",\n        \"STANDARD_CONCEPT\": \"\",\n        \"STANDARD_CONCEPT_CAPTION\": \"\",\n        \"INVALID_REASON\": \"\",\n        \"INVALID_REASON_CAPTION\": \"\",\n        \"CONCEPT_CODE\": \"\",\n        \"DOMAIN_ID\": \"\",\n        \"VOCABULARY_ID\": \"\",\n        \"CONCEPT_CLASS_ID\": \"\"\n      },\n      \"isExcluded\": false,\n      \"includeDescendants\": true,\n      \"includeMapped\": false\n    }\n  ]\n}\n```\n:::\n:::\n\n\n:::\n\nAnd now we can add this excluision criteria to our cohort definition.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngibleed_no_RA_cohort_definition <- cohort(\n  entry = entry_criteria,\n  attrition = attrition(\n    exactly(0, \n            condition(rheumatoid_arthritis_concept_set),\n            duringInterval(eventStarts(-Inf, Inf))))\n)\n```\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## JSON representation of a cohort\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(as.json((gibleed_cohort_definition)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n  \"ConceptSets\": [\n    {\n      \"id\": 0,\n      \"name\": \"\",\n      \"expression\": {\n        \"items\": [\n          {\n            \"concept\": {\n              \"CONCEPT_ID\": 192671,\n              \"CONCEPT_NAME\": \"\",\n              \"STANDARD_CONCEPT\": \"\",\n              \"STANDARD_CONCEPT_CAPTION\": \"\",\n              \"INVALID_REASON\": \"\",\n              \"INVALID_REASON_CAPTION\": \"\",\n              \"CONCEPT_CODE\": \"\",\n              \"DOMAIN_ID\": \"\",\n              \"VOCABULARY_ID\": \"\",\n              \"CONCEPT_CLASS_ID\": \"\"\n            },\n            \"isExcluded\": false,\n            \"includeDescendants\": true,\n            \"includeMapped\": false\n          }\n        ]\n      }\n    }\n  ],\n  \"PrimaryCriteria\": {\n    \"CriteriaList\": [\n      {\n        \"ConditionOccurrence\": {\n          \"CodesetId\": 0\n        }\n      }\n    ],\n    \"ObservationWindow\": {\n      \"PriorDays\": 0,\n      \"PostDays\": 0\n    },\n    \"PrimaryCriteriaLimit\": {\n      \"Type\": \"First\"\n    }\n  },\n  \"QualifiedLimit\": {\n    \"Type\": \"First\"\n  },\n  \"ExpressionLimit\": {\n    \"Type\": \"First\"\n  },\n  \"InclusionRules\": [],\n  \"CensoringCriteria\": [],\n  \"CollapseSettings\": {\n    \"CollapseType\": \"ERA\",\n    \"EraPad\": 0\n  },\n  \"CensorWindow\": {},\n  \"cdmVersionRange\": \">=5.0.0\"\n}\n```\n:::\n\n```{.r .cell-code}\ncat(as.json((gibleed_no_RA_cohort_definition)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n  \"ConceptSets\": [\n    {\n      \"id\": 0,\n      \"name\": \"\",\n      \"expression\": {\n        \"items\": [\n          {\n            \"concept\": {\n              \"CONCEPT_ID\": 192671,\n              \"CONCEPT_NAME\": \"\",\n              \"STANDARD_CONCEPT\": \"\",\n              \"STANDARD_CONCEPT_CAPTION\": \"\",\n              \"INVALID_REASON\": \"\",\n              \"INVALID_REASON_CAPTION\": \"\",\n              \"CONCEPT_CODE\": \"\",\n              \"DOMAIN_ID\": \"\",\n              \"VOCABULARY_ID\": \"\",\n              \"CONCEPT_CLASS_ID\": \"\"\n            },\n            \"isExcluded\": false,\n            \"includeDescendants\": true,\n            \"includeMapped\": false\n          }\n        ]\n      }\n    },\n    {\n      \"id\": 1,\n      \"name\": \"\",\n      \"expression\": {\n        \"items\": [\n          {\n            \"concept\": {\n              \"CONCEPT_ID\": 80809,\n              \"CONCEPT_NAME\": \"\",\n              \"STANDARD_CONCEPT\": \"\",\n              \"STANDARD_CONCEPT_CAPTION\": \"\",\n              \"INVALID_REASON\": \"\",\n              \"INVALID_REASON_CAPTION\": \"\",\n              \"CONCEPT_CODE\": \"\",\n              \"DOMAIN_ID\": \"\",\n              \"VOCABULARY_ID\": \"\",\n              \"CONCEPT_CLASS_ID\": \"\"\n            },\n            \"isExcluded\": false,\n            \"includeDescendants\": true,\n            \"includeMapped\": false\n          }\n        ]\n      }\n    }\n  ],\n  \"PrimaryCriteria\": {\n    \"CriteriaList\": [\n      {\n        \"ConditionOccurrence\": {\n          \"CodesetId\": 0\n        }\n      }\n    ],\n    \"ObservationWindow\": {\n      \"PriorDays\": 0,\n      \"PostDays\": 0\n    },\n    \"PrimaryCriteriaLimit\": {\n      \"Type\": \"First\"\n    }\n  },\n  \"QualifiedLimit\": {\n    \"Type\": \"First\"\n  },\n  \"ExpressionLimit\": {\n    \"Type\": \"First\"\n  },\n  \"InclusionRules\": [\n    {\n      \"name\": \"rule1\",\n      \"expression\": {\n        \"Criteria\": {\n          \"ConditionOccurrence\": {\n            \"CodesetId\": 1\n          }\n        },\n        \"StartWindow\": {\n          \"Start\": {\n            \"Coeff\": -1\n          },\n          \"End\": {\n            \"Coeff\": 1\n          },\n          \"UseIndexEnd\": false,\n          \"UseEventEnd\": false\n        },\n        \"Occurrence\": {\n          \"Type\": 0,\n          \"Count\": 0\n        }\n      }\n    }\n  ],\n  \"CensoringCriteria\": [],\n  \"CollapseSettings\": {\n    \"CollapseType\": \"ERA\",\n    \"EraPad\": 0\n  },\n  \"CensorWindow\": {},\n  \"cdmVersionRange\": \">=5.0.0\"\n}\n```\n:::\n:::\n\n\n:::\n\n## Adding a cohort to the CDM\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm <- generateCohortSet(\n  cdm,\n  list(gibleed = gibleed_cohort_definition,\n       gibleed_no_RA = gibleed_no_RA_cohort_definition\n       ),\n  name = \"gibleed\",\n  computeAttrition = TRUE,\n  overwrite = TRUE\n)\ncdm$gibleed %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 4\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpiaGigM\\file526848765190.duckdb]\n$ cohort_definition_id <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1~\n$ subject_id           <dbl> 264, 613, 757, 893, 1117, 1313, 1491, 1576, 1935,~\n$ cohort_start_date    <date> 1984-06-22, 1977-02-09, 1950-01-22, 1993-11-09, ~\n$ cohort_end_date      <date> 2011-11-18, 2019-06-14, 1998-10-25, 2019-05-06, ~\n```\n:::\n:::\n\n\n\n## Adding a concept- based cohort to the CDM\n\n# Cohort attributes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncohortSet(cdm$gibleed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  cohort_definition_id cohort_name  \n                 <int> <chr>        \n1                    1 gibleed      \n2                    2 gibleed_no_RA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncohortCount(cdm$gibleed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  cohort_definition_id number_records number_subjects\n                 <int>          <dbl>           <dbl>\n1                    1            479             479\n2                    2            479             479\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncohortAttrition(cdm$gibleed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 7\n  cohort_definition_id number_records number_subjects reason_id reason          \n                 <int>          <dbl>           <dbl>     <dbl> <chr>           \n1                    1            479             479         1 Qualifying init~\n2                    2            479             479         1 Qualifying init~\n3                    2            479             479         2 rule1           \n# i 2 more variables: excluded_records <dbl>, excluded_subjects <dbl>\n```\n:::\n:::\n\n\n\n# Custom cohort creation\n\n# Reconnecting to a database with existing cohorts\n\nAnd if we already had some permanent cohort tables in the results schema, we could include references to these when creating our cdm reference like so:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm <- cdm_from_con(db,\n  cdm_schema = \"main\",\n  write_schema = \"results\",\n  cohort_tables = c(\"exposure_cohort\", \"outcome_cohort\"))\n```\n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Controlling use of temp vs permanent tables\n\nTO DO - explain use of options to set behaviour\n:::\n",
    "supporting": [
      "ch_4_building_a_cohort_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}