{
  "hash": "12e5ab10e78cb3a51f0bf6b9eb9e3658",
  "result": {
    "markdown": "## Exploring the CDM\n\nLet's first connect again to our Eunomia data and create the reference to the common data model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dbplyr)\nlibrary(dplyr)\nlibrary(CDMConnector)\nlibrary(ggplot2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndb <- DBI::dbConnect(duckdb::duckdb(), \n                     dbdir = CDMConnector::eunomia_dir())\ncdm <- cdm_from_con(db, cdm_schema = \"main\")\n```\n:::\n\n\n## Vocabulary tables\nADD SOME INTRODUCTION TO THE VOCAB TABLES\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$concept %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 10\nDatabase: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n$ concept_id       <dbl> 35208414, 1118088, 40213201, 1557272, 4336464, 429588…\n$ concept_name     <chr> \"Gastrointestinal hemorrhage, unspecified\", \"celecoxi…\n$ domain_id        <chr> \"Condition\", \"Drug\", \"Drug\", \"Drug\", \"Procedure\", \"Pr…\n$ vocabulary_id    <chr> \"ICD10CM\", \"RxNorm\", \"CVX\", \"RxNorm\", \"SNOMED\", \"SNOM…\n$ concept_class_id <chr> \"4-char billing code\", \"Branded Drug\", \"CVX\", \"Ingred…\n$ standard_concept <chr> NA, \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", NA, NA, \"S\", \"…\n$ concept_code     <chr> \"K92.2\", \"213469\", \"33\", \"46041\", \"232717009\", \"76601…\n$ valid_start_date <date> 2007-01-01, 1970-01-01, 2008-12-01, 1970-01-01, 1970…\n$ valid_end_date   <date> 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n```\n:::\n:::\n\n\n\n## Counting people\n\nThe OMOP CDM is person-centric, with the person table containing records to uniquely identify each person in the database. As each row refers to a unique person, we can quickly get a count of the number of individuals in the database like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  count() %>% \n  pull()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2694\n```\n:::\n:::\n\n\nThe person table also contains some demographic information, including a gender_concept_id for each person. We can get a count grouped by this variable, but as this uses a concept we'll also need to join to the concept table to get the corresponding concept name for each concept id.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  group_by(gender_concept_id) %>% \n  count() %>% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %>% \n              select(\"gender_concept_id\", \"concept_name\", \"n\") %>% \n  collect()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  gender_concept_id concept_name     n\n              <dbl> <chr>        <dbl>\n1              8532 FEMALE        1373\n2              8507 MALE          1321\n```\n:::\n:::\n\n\nThe observation period table contains records indicating spans of time over which clinical events can be reliably observed for the people in the person table. Someone can potentially have multiple observation periods. So say we wanted a count of people grouped by the year during which their first observation period started. We could do this like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_observation_period <- cdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(dplyr::row_number() == 1) %>% \n    compute()\n\ncdm$person %>% \n  left_join(first_observation_period,\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  collect() %>% \n  ggplot() +\n  geom_col(aes(observation_period_start_year, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## To compute or not to compute\n\nThe compute() function will force the computation of a query. In the example above we use it to split up two queries; the first to keep the first observation period record for each individual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(dplyr::row_number() == 1) %>% \n    show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_date,\n  observation_period_end_date,\n  period_type_concept_id\nFROM (\n  SELECT *, ROW_NUMBER() OVER (PARTITION BY person_id) AS q03\n  FROM main.observation_period\n) q01\nWHERE (q03 = 1.0)\n```\n:::\n:::\n\n\nFollowed by a second query that left joins the person table with the result from the first (which is now in a temporary table), followed by extracted the year in which peoples first observation period starts and then, finally, a count by year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(first_observation_period,\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    *,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      LHS.person_id AS person_id,\n      gender_concept_id,\n      year_of_birth,\n      month_of_birth,\n      day_of_birth,\n      birth_datetime,\n      race_concept_id,\n      ethnicity_concept_id,\n      location_id,\n      provider_id,\n      care_site_id,\n      person_source_value,\n      gender_source_value,\n      gender_source_concept_id,\n      race_source_value,\n      race_source_concept_id,\n      ethnicity_source_value,\n      ethnicity_source_concept_id,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person AS LHS\n    LEFT JOIN dbplyr_001 AS RHS\n      ON (LHS.person_id = RHS.person_id)\n  ) q01\n) q02\nGROUP BY observation_period_start_year\n```\n:::\n:::\n\n\nWe could, however, have done this without compute, with instead the SQL being done all at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(cdm$observation_period %>%\n    group_by(person_id) %>% \n    filter(dplyr::row_number() == 1),\n            by = \"person_id\") %>% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %>% \n  group_by(observation_period_start_year) %>% \n  count() %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    *,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      LHS.person_id AS person_id,\n      gender_concept_id,\n      year_of_birth,\n      month_of_birth,\n      day_of_birth,\n      birth_datetime,\n      race_concept_id,\n      ethnicity_concept_id,\n      location_id,\n      provider_id,\n      care_site_id,\n      person_source_value,\n      gender_source_value,\n      gender_source_concept_id,\n      race_source_value,\n      race_source_concept_id,\n      ethnicity_source_value,\n      ethnicity_source_concept_id,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person AS LHS\n    LEFT JOIN (\n      SELECT\n        observation_period_id,\n        person_id,\n        observation_period_start_date,\n        observation_period_end_date,\n        period_type_concept_id\n      FROM (\n        SELECT *, ROW_NUMBER() OVER (PARTITION BY person_id) AS q03\n        FROM main.observation_period\n      ) q01\n      WHERE (q03 = 1.0)\n    ) RHS\n      ON (LHS.person_id = RHS.person_id)\n  ) q02\n) q03\nGROUP BY observation_period_start_year\n```\n:::\n:::\n\n\nIn this case the SQL is not much more complicated than before. However, you can imagine that without forcing computation, the SQL associated with a series of data manipulations could quickly become unmanageable. So although we don't want to overuse compute, it is often a necessity when writing analysis scripts.\n\nAn advantage of using compute, is that we can use the result for multiple subsequent queries. For example, say we want a count of condition occurrence and drug exposure records for those born before 1970. We could get these counts independently:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  select(\"person_id\") %>% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n      n\n  <dbl>\n1 51858\n```\n:::\n\n```{.r .cell-code}\ncdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  select(\"person_id\") %>% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n      n\n  <dbl>\n1 49447\n```\n:::\n:::\n\n\nBut we could have instead first subsetted the person table and then used the result for both queries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person_pre_1970 <- cdm$person %>% \n  filter(year_of_birth < \"1970\") %>% \n  compute()\n\ncdm$person_pre_1970 %>% \n  select(\"person_id\") %>% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n      n\n  <dbl>\n1 51858\n```\n:::\n\n```{.r .cell-code}\ncdm$person_pre_1970 %>% \n  select(\"person_id\") %>% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %>% \n  tally()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n      n\n  <dbl>\n1 49447\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## computeQuery()\n\nThe `compute()` function from dplyr is currently somewhat inconsistent across database platforms. For this reason CDMConnector provides the `computeQuery()` which does the same job, but with greater consistency across its supported database management systems.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  tally() %>% \n  computeQuery()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Source:   table<dbplyr_003> [1 x 1]\n# Database: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n      n\n  <dbl>\n1  2694\n```\n:::\n:::\n\n:::\n\n## Counting records\n\nNumber of drug exposure records per person\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  left_join(cdm$measurement %>% \n  group_by(person_id) %>% \n  count(name = \"condition_occurrence_records\"),\n            by=\"person_id\") %>% \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), 0,\n    condition_occurrence_records)) %>% \n  group_by(condition_occurrence_records) %>%\n  count() %>% \n  collect() %>% \n  ggplot() +\n  geom_col(aes(condition_occurrence_records, n)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## Working with dates\n\nDates are supported somewhat inconsistently by dbplyr but, as with `computeQuery()`, CDMConnector also provides some date functions that are tested to work across supported databases. We can use the `datediff()` function for example to calculate the difference between two dates. We can use this below to get the number of years observation periods last for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  dplyr::mutate(observation_years = \n                  !!CDMConnector::datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\"))  %>% \n  collect() %>% \n  ggplot() +\n  geom_histogram(aes(observation_years), \n                 binwidth=2, colour=\"grey\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## Statistical summaries\n\nWe can also use summarise for various other calculations\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE),\n            mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>%  \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: ??\nColumns: 6\nDatabase: DuckDB 0.5.1 [edbur@Windows 10 x64:R 4.2.1/C:\\Users\\edbur\\AppData\\Local\\Temp\\RtmpaqH8R0/zjntpkde]\n$ min_year_of_birth    <dbl> 1908\n$ q05_year_of_birth    <dbl> 1922\n$ mean_year_of_birth   <dbl> 1958\n$ median_year_of_birth <dbl> 1961\n$ q95_year_of_birth    <dbl> 1979\n$ max_year_of_birth    <dbl> 1986\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Piping and SQL\n\nAlthough piping queries has little impact on performance when using R with data in memory, when working with a database the SQL generated will differ when using multiple function calls (with a separate operation specified in each) instead of multiple operations within a single function call.\n\nFor example, the single summarise function above would generate the below SQL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE),\n            mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  MIN(year_of_birth) AS min_year_of_birth,\n  PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY year_of_birth) AS q05_year_of_birth,\n  ROUND(AVG(year_of_birth), CAST(ROUND(0.0, 0) AS INTEGER)) AS mean_year_of_birth,\n  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY year_of_birth) AS median_year_of_birth,\n  PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY year_of_birth) AS q95_year_of_birth,\n  MAX(year_of_birth) AS max_year_of_birth\nFROM main.person\n```\n:::\n:::\n\n\nCalling summarise for each though would lead to a more involved query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE)) %>% \n  summarise(q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE)) %>% \n  summarise(mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0)) %>% \n  summarise(median_year_of_birth = median(year_of_birth, na.rm=TRUE)) %>% \n  summarise(q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE)) %>% \n  summarise(max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT MAX(year_of_birth) AS max_year_of_birth\nFROM (\n  SELECT PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY year_of_birth) AS q95_year_of_birth\n  FROM (\n    SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY year_of_birth) AS median_year_of_birth\n    FROM (\n      SELECT ROUND(AVG(year_of_birth), CAST(ROUND(0.0, 0) AS INTEGER)) AS mean_year_of_birth\n      FROM (\n        SELECT PERCENTILE_CONT(0.05) WITHIN GROUP (ORDER BY year_of_birth) AS q05_year_of_birth\n        FROM (\n          SELECT MIN(year_of_birth) AS min_year_of_birth\n          FROM main.person\n        ) q01\n      ) q02\n    ) q03\n  ) q04\n) q05\n```\n:::\n:::\n\n\nA similar story can be seen with mutate\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  mutate(observation_days = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"day\"),\n        observation_years = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\")) %>% \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_days\",\"observation_years\") %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  datediff('day', observation_period_start_date, observation_period_end_date) AS observation_days,\n  datediff('year', observation_period_start_date, observation_period_end_date) AS observation_years\nFROM main.observation_period\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$observation_period %>%\n  mutate(observation_days = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"day\")) %>% \n  mutate(observation_years = !!datediff(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \n                             interval = \"year\")) %>% \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_days\",\"observation_years\") %>% \n  show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<SQL>\nSELECT\n  observation_period_id,\n  person_id,\n  observation_days,\n  datediff('year', observation_period_start_date, observation_period_end_date) AS observation_years\nFROM (\n  SELECT\n    *,\n    datediff('day', observation_period_start_date, observation_period_end_date) AS observation_days\n  FROM main.observation_period\n) q01\n```\n:::\n:::\n\n:::\n\nAs we've seen before, we can also quickly get results for various groupings or restrictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdm$person %>% \n   group_by(gender_concept_id) %>% \n   summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q25_year_of_birth = quantile(year_of_birth, 0.25, na.rm=TRUE),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q75_year_of_birth = quantile(year_of_birth, 0.75, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %>% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %>% \n   collect() %>% \n  ggplot(aes(x = concept_name, group = concept_name,\n             fill = concept_name)) +\n  geom_boxplot(aes(\n    lower = q25_year_of_birth, \n    upper = q75_year_of_birth, \n    middle = median_year_of_birth, \n    ymin = min_year_of_birth, \n    ymax = max_year_of_birth),\n    stat = \"identity\", width = 0.5) + \n  theme_bw()+ \n  theme(legend.position = \"none\") +\n  xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](ch_3_exploring_the_cdm_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ch_3_exploring_the_cdm_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}