[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tidy R programming with the OMOP common data model",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "ch_1_getting_started.html",
    "href": "ch_1_getting_started.html",
    "title": "1  Getting started",
    "section": "",
    "text": "Artwork by @allison_horst\nBefore we start thinking about working with health care data spread across a database using the OMOP common data model, let’s first do a quick data analysis from R using a simpler dataset held in a database. For this we’ll use data from palmerpenguins package, which contains data on penguins collected from the Palmer Station in Antarctica."
  },
  {
    "objectID": "ch_1_getting_started.html#getting-set-up",
    "href": "ch_1_getting_started.html#getting-set-up",
    "title": "1  Getting started",
    "section": "1.2 Getting set up",
    "text": "1.2 Getting set up\nAssuming that you have R and RStudio already set up, first we need to install a few packages not included in base R if we don´t already have them.\n\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggplot2\")\ninstall.packages(\"DBI\")\ninstall.packages(\"duckdb\")\ninstall.packages(\"palmerpenguins\")\n\nOnce installed, we can load them like so.\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(DBI)\nlibrary(duckdb)\nlibrary(palmerpenguins)"
  },
  {
    "objectID": "ch_1_getting_started.html#taking-a-peek-at-the-data",
    "href": "ch_1_getting_started.html#taking-a-peek-at-the-data",
    "title": "1  Getting started",
    "section": "1.3 Taking a peek at the data",
    "text": "1.3 Taking a peek at the data\nWe can get an overview of the data using the glimpse() command.\n\nglimpse(penguins)\n\nRows: 344\nColumns: 8\n$ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\nOr we could take a look at the first rows of the data using head()\n\nhead(penguins, 5)\n\n# A tibble: 5 × 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "ch_1_getting_started.html#inserting-data-into-a-database",
    "href": "ch_1_getting_started.html#inserting-data-into-a-database",
    "title": "1  Getting started",
    "section": "1.4 Inserting data into a database",
    "text": "1.4 Inserting data into a database\nLet’s put our penguins data into a duckdb database. We create the duckdb database, add the penguins data, and then create a reference to the table containing the data.\n\ndb &lt;- dbConnect(duckdb::duckdb(), dbdir = \":memory:\")\ndbWriteTable(db, \"penguins\", penguins)\npenguins_db &lt;- tbl(db, \"penguins\")\n\nWe can see that our database now has one table\n\nDBI::dbListTables(db)\n\n[1] \"penguins\"\n\n\nAnd now that the data is in a database we could use SQL to get the first rows that we saw before\n\ndbGetQuery(db, \"SELECT * FROM penguins LIMIT 5\")\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n\n\nBut we could also use the same R code as before\n\nhead(penguins_db, 5)\n\n# Source:   SQL [5 x 8]\n# Database: DuckDB v0.10.3-dev797 [eburn@Windows 10 x64:R 4.2.1/:memory:]\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "ch_1_getting_started.html#translation-from-r-to-sql",
    "href": "ch_1_getting_started.html#translation-from-r-to-sql",
    "title": "1  Getting started",
    "section": "1.5 Translation from R to SQL",
    "text": "1.5 Translation from R to SQL\nThe magic here is provided by the dbplyr which takes the R code and converts it into SQL, which in this case looks like\n\nhead(penguins_db, 5) %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT penguins.*\nFROM penguins\nLIMIT 5\n\n\nMore complicated SQL can also be generated by using familiar dplyr code, for example\n\npenguins_db %&gt;%\n  group_by(species) %&gt;%\n  summarise(\n    min_bill_length_mm = min(bill_length_mm),\n    median_bill_length_mm = median(bill_length_mm),\n    max_bill_length_mm = max(bill_length_mm)\n  ) %&gt;%\n  mutate(min_max_bill_length_mm = paste0(\n    min_bill_length_mm,\n    \" to \",\n    max_bill_length_mm\n  )) %&gt;%\n  select(\n    \"species\",\n    \"median_bill_length_mm\",\n    \"min_max_bill_length_mm\"\n  )\n\n# Source:   SQL [3 x 3]\n# Database: DuckDB v0.10.3-dev797 [eburn@Windows 10 x64:R 4.2.1/:memory:]\n  species   median_bill_length_mm min_max_bill_length_mm\n  &lt;fct&gt;                     &lt;dbl&gt; &lt;chr&gt;                 \n1 Adelie                     38.8 32.1 to 46.0          \n2 Chinstrap                  49.6 40.9 to 58.0          \n3 Gentoo                     47.3 40.9 to 59.6          \n\n\nIn this case the corresponding SQL looks like\n\npenguins_db %&gt;%\n  group_by(species) %&gt;%\n  summarise(\n    min_bill_length_mm = min(bill_length_mm),\n    median_bill_length_mm = median(bill_length_mm),\n    max_bill_length_mm = max(bill_length_mm)\n  ) %&gt;%\n  mutate(min_max_bill_length_mm = paste0(min, \" to \", max)) %&gt;%\n  select(\n    \"species\",\n    \"median_bill_length_mm\",\n    \"min_max_bill_length_mm\"\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  species,\n  median_bill_length_mm,\n  CONCAT_WS('', .Primitive(\"min\"), ' to ', .Primitive(\"max\")) AS min_max_bill_length_mm\nFROM (\n  SELECT\n    species,\n    MIN(bill_length_mm) AS min_bill_length_mm,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bill_length_mm) AS median_bill_length_mm,\n    MAX(bill_length_mm) AS max_bill_length_mm\n  FROM penguins\n  GROUP BY species\n) q01\n\n\n\n\n\n\n\n\nDifferent SQL for different database management systems\n\n\n\n\n\nOne important benefit of using this approach is that the SQL generated will be specific to that of the database management system in use.\nAs we can see below the SQL can vary depending on the database management system being used.\n\npenguins %&gt;%\n  dbplyr::lazy_frame(con = duckdb::simulate_duckdb()) %&gt;%\n  mutate(\n    category = if_else(bill_length_mm &gt; 40 & bill_depth_mm &gt; 18,\n      \"big\", \"small\"\n    ),\n    date = as.Date(paste0(\"01-01-\", year))\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  `df`.*,\n  CASE WHEN (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'big' WHEN NOT (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'small' END AS `category`,\n  CAST(CONCAT_WS('', '01-01-', `year`) AS DATE) AS `date`\nFROM `df`\n\npenguins %&gt;%\n  dbplyr::lazy_frame(con = dbplyr::simulate_postgres()) %&gt;%\n  mutate(\n    category = if_else(bill_length_mm &gt; 40 & bill_depth_mm &gt; 18,\n      \"big\", \"small\"\n    ),\n    date = as.Date(paste0(\"01-01-\", year))\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  `df`.*,\n  CASE WHEN (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'big' WHEN NOT (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'small' END AS `category`,\n  CAST(CONCAT_WS('', '01-01-', `year`) AS DATE) AS `date`\nFROM `df`\n\npenguins %&gt;%\n  dbplyr::lazy_frame(con = dbplyr::simulate_redshift()) %&gt;%\n  mutate(\n    category = if_else(bill_length_mm &gt; 40 & bill_depth_mm &gt; 18,\n      \"big\", \"small\"\n    ),\n    date = as.Date(paste0(\"01-01-\", year))\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  `df`.*,\n  CASE WHEN (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'big' WHEN NOT (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'small' END AS `category`,\n  CAST('01-01-' || `year` AS DATE) AS `date`\nFROM `df`\n\npenguins %&gt;%\n  dbplyr::lazy_frame(con = dbplyr::simulate_oracle()) %&gt;%\n  mutate(\n    category = if_else(bill_length_mm &gt; 40 & bill_depth_mm &gt; 18,\n      \"big\", \"small\"\n    ),\n    date = as.Date(paste0(\"01-01-\", year))\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  `df`.*,\n  CASE WHEN (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'big' WHEN NOT (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'small' END AS `category`,\n  DATE '01-01-' || `year` AS `date`\nFROM `df`\n\npenguins %&gt;%\n  dbplyr::lazy_frame(con = dbplyr::simulate_snowflake()) %&gt;%\n  mutate(\n    category = if_else(bill_length_mm &gt; 40 & bill_depth_mm &gt; 18,\n      \"big\", \"small\"\n    ),\n    date = as.Date(paste0(\"01-01-\", year))\n  ) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  `df`.*,\n  CASE WHEN (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'big' WHEN NOT (`bill_length_mm` &gt; 40.0 AND `bill_depth_mm` &gt; 18.0) THEN 'small' END AS `category`,\n  CAST(ARRAY_TO_STRING(ARRAY_CONSTRUCT_COMPACT('01-01-', `year`), '') AS DATE) AS `date`\nFROM `df`"
  },
  {
    "objectID": "ch_1_getting_started.html#example-analysis",
    "href": "ch_1_getting_started.html#example-analysis",
    "title": "1  Getting started",
    "section": "1.6 Example analysis",
    "text": "1.6 Example analysis\nLet´s start by getting a count by species\n\npenguins_db %&gt;% \n  group_by(species) %&gt;% \n  count()\n\n# Source:   SQL [3 x 2]\n# Database: DuckDB v0.10.3-dev797 [eburn@Windows 10 x64:R 4.2.1/:memory:]\n# Groups:   species\n  species       n\n  &lt;fct&gt;     &lt;dbl&gt;\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n\n\nNow suppose we are particularly interested in the body mass variable. We can first notice that there are a couple of missing records for this.\n\npenguins_db %&gt;%\n  mutate(missing_body_mass_g = if_else(\n    is.na(body_mass_g), 1, 0\n  )) %&gt;%\n  group_by(species, missing_body_mass_g) %&gt;%\n  tally()\n\n# Source:   SQL [5 x 3]\n# Database: DuckDB v0.10.3-dev797 [eburn@Windows 10 x64:R 4.2.1/:memory:]\n  species   missing_body_mass_g     n\n  &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;\n1 Adelie                      1     1\n2 Adelie                      0   151\n3 Gentoo                      0   123\n4 Chinstrap                   0    68\n5 Gentoo                      1     1\n\n\nWe can get the mean for each of the species (dropping those two missing records).\n\npenguins_db %&gt;%\n  group_by(species) %&gt;%\n  summarise(mean_body_mass_g = round(mean(body_mass_g, na.rm = TRUE), 0))\n\n# Source:   SQL [3 x 2]\n# Database: DuckDB v0.10.3-dev797 [eburn@Windows 10 x64:R 4.2.1/:memory:]\n  species   mean_body_mass_g\n  &lt;fct&gt;                &lt;dbl&gt;\n1 Adelie                3701\n2 Chinstrap             3733\n3 Gentoo                5076\n\n\nWe can then also make a histogram for each of the species.\n\npenguins_db %&gt;%\n  collect() %&gt;%\n  ggplot(aes(group = species, fill = species)) +\n  facet_grid(species ~ .) +\n  geom_histogram(aes(body_mass_g), colour = \"black\", binwidth = 100) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\nChoosing the right time to collect\n\n\n\n\n\ncollect() brings data out of the database and into R. Above we use it to bring the entire penguins data back into R so that we can then use ggplot() to make our histogram.\nGenerally speaking we want to keep as much computation as possible on the database side, up until the point we need to bring the data out for further analysis steps that are not possible using SQL. This could be like the case above for plotting, but could also be for other analytic steps like fitting statistical models. In such cases it is important that we only bring out the required data.\n\n\n\nHow about the relationship between body mass and bill depth?\n\npenguins %&gt;%\n  collect() %&gt;%\n  ggplot(aes(x = bill_depth_mm, y = body_mass_g)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\nSo a negative correlation between body mass and bill depth - that seems rather unexpected. But what about if we stratify by species?\n\npenguins %&gt;%\n  collect() %&gt;%\n  ggplot(aes(x = bill_depth_mm, y = body_mass_g)) +\n  facet_grid(species ~ .) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\nAs well as having an example of working with data in database from R, you also have an example of Simpson´s paradox!"
  },
  {
    "objectID": "ch_1_getting_started.html#disconnecting-from-the-database",
    "href": "ch_1_getting_started.html#disconnecting-from-the-database",
    "title": "1  Getting started",
    "section": "1.7 Disconnecting from the database",
    "text": "1.7 Disconnecting from the database\nAnd now we’ve reached the end of this example, we can close our connection to the database.\n\ndbDisconnect(db)"
  },
  {
    "objectID": "ch_1_getting_started.html#further-reading",
    "href": "ch_1_getting_started.html#further-reading",
    "title": "1  Getting started",
    "section": "1.8 Further reading",
    "text": "1.8 Further reading\n\nR for Data Science (Chapter 13: Relational data)\nWriting SQL with dbplyr\nData Carpentry: SQL databases and R"
  },
  {
    "objectID": "ch_2_cdm_reference.html",
    "href": "ch_2_cdm_reference.html",
    "title": "2  Creating a reference to the OMOP common data model",
    "section": "",
    "text": "3 Database snapshot\nAfter creating our cdm reference we can get a summary of the metadata for the OMOP CDM data using the snapshot() function from CDMConnector.\ncdm_snapshot &lt;- cdm_from_con(con = db, \n                             cdm_name = \"my_cdm\",\n                             cdm_schema = \"main\", \n                             write_schema = \"main\") %&gt;% \n  snapshot()\ncdm_snapshot %&gt;% \n  glimpse()\n\nRows: 1\nColumns: 13\n$ cdm_name                               &lt;chr&gt; \"my_cdm\"\n$ cdm_source_name                        &lt;chr&gt; \"Synthea\"\n$ cdm_description                        &lt;chr&gt; \"Synthea Synthetic Data\"\n$ cdm_documentation_reference            &lt;chr&gt; \"https://synthetichealth.github…\n$ cdm_version                            &lt;chr&gt; \"5.3.1\"\n$ cdm_holder                             &lt;chr&gt; \"\"\n$ cdm_release_date                       &lt;chr&gt; \"2023-06-14\"\n$ vocabulary_version                     &lt;chr&gt; \"v5.0 22-JUN-22\"\n$ person_count                           &lt;chr&gt; \"10754\"\n$ observation_period_count               &lt;chr&gt; \"10754\"\n$ earliest_observation_period_start_date &lt;chr&gt; \"1923-12-29\"\n$ latest_observation_period_end_date     &lt;chr&gt; \"2023-06-14\"\n$ snapshot_date                          &lt;chr&gt; \"2024-02-17\"\nOnce we have finished our analysis we can close our connection to the database behind our cdm reference like so.\ncdmDisconnect(cdm)\nThis is equivalent to closing the connection directly like we saw in the previous chapter.\ndbDisconnect(attr(cdm, \"dbcon\"))"
  },
  {
    "objectID": "ch_2_cdm_reference.html#creating-a-reference-to-the-omop-common-data-model",
    "href": "ch_2_cdm_reference.html#creating-a-reference-to-the-omop-common-data-model",
    "title": "2  Creating a reference to the OMOP common data model",
    "section": "2.2 Creating a reference to the OMOP common data model",
    "text": "2.2 Creating a reference to the OMOP common data model\nAs seen in the previous chapter, once a connection to the database has been created we could then create references to the various tables in the database and build queries using in a familiar dplyr style. However, as the structure of the OMOP CDM is already known, we can avoid the overhead of creating individual references to the OMOP CDM tables by using the CDMConnector package. CDMConnector will do the work for us and quickly create a joint reference for all OMOP CDM database tables.\nIf you don’t already have it installed, the first step would be to install CDMConnector from CRAN.\n\ninstall.packages(\"CDMConnector\")\n\nFor this example, we’ll use an example dataset (synthea-covid19-10k) provided by CDMConnector. First let’s load packages and then download the example data.\n\nlibrary(DBI)\nlibrary(CDMConnector)\nlibrary(here)\n\n\ndownloadEunomiaData(\n  datasetName = \"synthea-covid19-10k\",\n  cdmVersion = \"5.3\",\n  pathToData = here(),\n  overwrite = FALSE\n)\n\nAfter connecting to the database containing the OMOP CDM, we use CDMConnector to create our cdm reference.\n\ndb &lt;- dbConnect(duckdb::duckdb(), \n              dbdir = eunomiaDir(datasetName = \"synthea-covid19-10k\"))\ncdm &lt;- cdm_from_con(con = db, \n                    cdm_schema = \"main\", \n                    write_schema = \"main\", \n                    cdm_name = \"Synthea Covid-19 data\")\ncdm\n\n\n\n\n── # OMOP CDM reference (duckdb) of Synthea Covid-19 data ──────────────────────\n\n\n• omop tables: person, observation_period, visit_occurrence, visit_detail,\ncondition_occurrence, drug_exposure, procedure_occurrence, device_exposure,\nmeasurement, observation, death, note, note_nlp, specimen, fact_relationship,\nlocation, care_site, provider, payer_plan_period, cost, drug_era, dose_era,\ncondition_era, metadata, cdm_source, concept, vocabulary, domain,\nconcept_class, concept_relationship, relationship, concept_synonym,\nconcept_ancestor, source_to_concept_map, drug_strength, cohort_definition,\nattribute_definition\n\n\n• cohort tables: -\n\n\n• achilles tables: -\n\n\n• other tables: -\n\n\nOnce we have created the our reference to the overall OMOP CDM, we can reference specific tables using the “$” operator.\n\ncdm$observation_period\n\n# Source:   table&lt;observation_period&gt; [?? x 5]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpARELHc\\file33647d9144f0.duckdb]\n   observation_period_id person_id observation_period_s…¹ observation_period_e…²\n                   &lt;int&gt;     &lt;int&gt; &lt;date&gt;                 &lt;date&gt;                \n 1                     1         1 2014-05-09             2023-05-12            \n 2                     2         2 1977-04-11             1986-09-15            \n 3                     3         3 2014-04-19             2023-04-22            \n 4                     4         4 2014-03-22             2023-04-08            \n 5                     5         5 2013-11-13             2023-01-04            \n 6                     6         6 2013-07-17             2021-08-04            \n 7                     7         7 2013-06-26             2022-08-17            \n 8                     8         8 2018-08-20             2022-07-25            \n 9                     9         9 2013-08-03             2022-09-24            \n10                    10        10 2013-08-11             2023-04-02            \n# ℹ more rows\n# ℹ abbreviated names: ¹​observation_period_start_date,\n#   ²​observation_period_end_date\n# ℹ 1 more variable: period_type_concept_id &lt;int&gt;\n\n\nAlternatively, you could also access a specific table reference like so\n\ncdm[[\"observation_period\"]]\n\n# Source:   table&lt;observation_period&gt; [?? x 5]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpARELHc\\file33647d9144f0.duckdb]\n   observation_period_id person_id observation_period_s…¹ observation_period_e…²\n                   &lt;int&gt;     &lt;int&gt; &lt;date&gt;                 &lt;date&gt;                \n 1                     1         1 2014-05-09             2023-05-12            \n 2                     2         2 1977-04-11             1986-09-15            \n 3                     3         3 2014-04-19             2023-04-22            \n 4                     4         4 2014-03-22             2023-04-08            \n 5                     5         5 2013-11-13             2023-01-04            \n 6                     6         6 2013-07-17             2021-08-04            \n 7                     7         7 2013-06-26             2022-08-17            \n 8                     8         8 2018-08-20             2022-07-25            \n 9                     9         9 2013-08-03             2022-09-24            \n10                    10        10 2013-08-11             2023-04-02            \n# ℹ more rows\n# ℹ abbreviated names: ¹​observation_period_start_date,\n#   ²​observation_period_end_date\n# ℹ 1 more variable: period_type_concept_id &lt;int&gt;\n\n\nWhen creating our cdm reference we can also specify a write schema. This would be a schema in which we have permission to create tables (as we’re unlikely to have that permission for the schema containing the tables with the patient-level data).\n\ncdm &lt;- cdm_from_con(db,\n  cdm_schema = \"main\",\n  write_schema = \"results\")\n\n\n\n\n\n\n\nSetting a write prefix\n\n\n\n\n\nWe can set a prefix that to use when permanent tables are created the write schema. This can be useful when we’re sharing our write schema with others and want to avoid table name conflicts.\n\ncdm &lt;- cdm_from_con(db,\n  cdm_schema = \"main\",\n  write_schema = c(schema=\"main\", prefix = \"example_\"))"
  },
  {
    "objectID": "ch_2_cdm_reference.html#cdm-name",
    "href": "ch_2_cdm_reference.html#cdm-name",
    "title": "2  Creating a reference to the OMOP common data model",
    "section": "2.3 CDM name",
    "text": "2.3 CDM name\nOur cdm reference will be associated with a name. By default this name will be taken from the cdm source name field from the cdm source table. We can though set this to a different name when creating our cdm reference. This cdm name attribute of our reference is particularly useful in the context of network studies to keep track of which results are associated with which database.\n\ncdm &lt;- cdm_from_con(db,\n  cdm_schema = \"main\", \n  write_schema = \"main\")\ncdm$cdm_source\n\n# Source:   table&lt;cdm_source&gt; [1 x 10]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpARELHc\\file33647d9144f0.duckdb]\n  cdm_source_name cdm_source_abbreviation cdm_holder source_description    \n  &lt;chr&gt;           &lt;chr&gt;                   &lt;chr&gt;      &lt;chr&gt;                 \n1 Synthea         Synthea                 \"\"         Synthea Synthetic Data\n# ℹ 6 more variables: source_documentation_reference &lt;chr&gt;,\n#   cdm_etl_reference &lt;chr&gt;, source_release_date &lt;date&gt;,\n#   cdm_release_date &lt;date&gt;, cdm_version &lt;chr&gt;, vocabulary_version &lt;chr&gt;\n\ncdm_name(cdm)\n\n[1] \"Synthea\"\n\ncdm &lt;- cdm_from_con(db,\n  cdm_schema = \"main\", \n  write_schema = \"main\", \n  cdm_name = \"my_cdm\")\ncdm_name(cdm)\n\n[1] \"my_cdm\""
  },
  {
    "objectID": "ch_3_exploring_the_cdm.html",
    "href": "ch_3_exploring_the_cdm.html",
    "title": "3  Exploring the CDM",
    "section": "",
    "text": "3.1 Counting people\nThe OMOP CDM is person-centric, with the person table containing records to uniquely identify each person in the database. As each row refers to a unique person, we can quickly get a count of the number of individuals in the database like so\ncdm$person %&gt;% \n  count() %&gt;% \n  pull()\n\n[1] 10754\nThe person table also contains some demographic information, including a gender concept for each person. We can get a count grouped by this variable, but as this uses a concept we’ll also need to join to the concept table to get the corresponding concept name for each concept id.\ncdm$person %&gt;% \n  group_by(gender_concept_id) %&gt;% \n  count() %&gt;% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %&gt;% \n              select(\"gender_concept_id\", \"concept_name\", \"n\") %&gt;% \n  collect()\n\n# A tibble: 2 × 3\n# Groups:   gender_concept_id [2]\n  gender_concept_id concept_name     n\n              &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt;\n1              8532 FEMALE        5165\n2              8507 MALE          5589\nThe observation period table contains records indicating spans of time over which clinical events can be reliably observed for the people in the person table. Someone can potentially have multiple observation periods. So say we wanted a count of people grouped by the year during which their first observation period started. We could do this like so:\nfirst_observation_period &lt;- cdm$observation_period %&gt;%\n    group_by(person_id) %&gt;% \n    filter(row_number() == 1) %&gt;% \n    compute()\n\ncdm$person %&gt;% \n  left_join(first_observation_period,\n            by = \"person_id\") %&gt;% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %&gt;% \n  group_by(observation_period_start_year) %&gt;% \n  count() %&gt;% \n  collect() %&gt;% \n  ggplot() +\n  geom_col(aes(observation_period_start_year, n)) +\n  theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploring the CDM</span>"
    ]
  },
  {
    "objectID": "ch_3_exploring_the_cdm.html#counting-people",
    "href": "ch_3_exploring_the_cdm.html#counting-people",
    "title": "3  Exploring the CDM",
    "section": "",
    "text": "Computing intermediate queries\n\n\n\n\n\nThe compute() function will force the computation of a query. In the example above we use it to split up two queries; the first to keep the first observation period record for each individual.\n\ncdm$observation_period %&gt;%\n    group_by(person_id) %&gt;% \n    filter(row_number() == 1) %&gt;% \n    show_query()\n\n&lt;SQL&gt;\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_date,\n  observation_period_end_date,\n  period_type_concept_id\nFROM (\n  SELECT\n    observation_period.*,\n    ROW_NUMBER() OVER (PARTITION BY person_id) AS col01\n  FROM main.observation_period\n) q01\nWHERE (col01 = 1.0)\n\n\nFollowed by a second query that left joins the person table with the result from the first (which is now in a temporary table), followed by extracted the year in which peoples first observation period starts and then, finally, a count by year.\n\ncdm$person %&gt;% \n  left_join(first_observation_period,\n            by = \"person_id\") %&gt;% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %&gt;% \n  group_by(observation_period_start_year) %&gt;% \n  count() %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    q01.*,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      person.*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person\n    LEFT JOIN og_001_1718360923\n      ON (person.person_id = og_001_1718360923.person_id)\n  ) q01\n) q01\nGROUP BY observation_period_start_year\n\n\nWe could, however, have done this without compute, with instead the SQL being done all at once.\n\ncdm$person %&gt;% \n  left_join(cdm$observation_period %&gt;%\n    group_by(person_id) %&gt;% \n    filter(row_number() == 1),\n            by = \"person_id\") %&gt;% \n  mutate(observation_period_start_year=year(observation_period_start_date)) %&gt;% \n  group_by(observation_period_start_year) %&gt;% \n  count() %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT observation_period_start_year, COUNT(*) AS n\nFROM (\n  SELECT\n    q01.*,\n    EXTRACT(year FROM observation_period_start_date) AS observation_period_start_year\n  FROM (\n    SELECT\n      person.*,\n      observation_period_id,\n      observation_period_start_date,\n      observation_period_end_date,\n      period_type_concept_id\n    FROM main.person\n    LEFT JOIN (\n      SELECT\n        observation_period_id,\n        person_id,\n        observation_period_start_date,\n        observation_period_end_date,\n        period_type_concept_id\n      FROM (\n        SELECT\n          observation_period.*,\n          ROW_NUMBER() OVER (PARTITION BY person_id) AS col01\n        FROM main.observation_period\n      ) q01\n      WHERE (col01 = 1.0)\n    ) RHS\n      ON (person.person_id = RHS.person_id)\n  ) q01\n) q01\nGROUP BY observation_period_start_year\n\n\nIn this case the SQL is not much more complicated than before. However, you can imagine that without using computation to intermediate tables, the SQL associated with a series of data manipulations could quickly become unmanageable. Although we don’t want to overuse computation of intermediate queries, it is often a necessity when writing study analysis scripts.\nAn advantage of computing a query, is that we can then use the result for multiple subsequent queries. For example, say we want a count of condition occurrence and drug exposure records for those born before 1970. We could get these counts independently:\n\ncdm$person %&gt;% \n  filter(year_of_birth &lt; \"1970\") %&gt;% \n  select(\"person_id\") %&gt;% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n      n\n  &lt;dbl&gt;\n1  9305\n\ncdm$person %&gt;% \n  filter(year_of_birth &lt; \"1970\") %&gt;% \n  select(\"person_id\") %&gt;% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n       n\n   &lt;dbl&gt;\n1 165681\n\n\nBut we could have instead first subsetted the person table and then used the result for both queries.\n\ncdm$person_pre_1970 &lt;- cdm$person %&gt;% \n  filter(year_of_birth &lt; \"1970\") %&gt;% \n  compute()\n\ncdm$person_pre_1970 %&gt;% \n  select(\"person_id\") %&gt;% \n  left_join(cdm$condition_occurrence,\n            by=\"person_id\") %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n      n\n  &lt;dbl&gt;\n1  9305\n\ncdm$person_pre_1970 %&gt;% \n  select(\"person_id\") %&gt;% \n  left_join(cdm$drug_exposure,\n            by=\"person_id\") %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n       n\n   &lt;dbl&gt;\n1 165681",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploring the CDM</span>"
    ]
  },
  {
    "objectID": "ch_3_exploring_the_cdm.html#counting-records",
    "href": "ch_3_exploring_the_cdm.html#counting-records",
    "title": "3  Exploring the CDM",
    "section": "3.2 Counting records",
    "text": "3.2 Counting records\nWhat’s the number of condition occurrence records per person in the database? We can find this out like so\n\ncdm$person %&gt;% \n  left_join(cdm$condition_occurrence %&gt;% \n  group_by(person_id) %&gt;% \n  count(name = \"condition_occurrence_records\"),\n  by=\"person_id\") %&gt;% \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), 0,\n    condition_occurrence_records)) %&gt;% \n  group_by(condition_occurrence_records) %&gt;%\n  count() %&gt;% \n  collect() %&gt;% \n  ggplot() +\n  geom_col(aes(condition_occurrence_records, n)) +\n  theme_bw()\n\n\n\n\n\n\n\n\nHow about we were interested in getting record counts for some specific concepts related to COVID-19 symptoms?\n\ncdm$condition_occurrence %&gt;% \n  filter(condition_concept_id %in% c(437663,437390,31967,\n                                     4289517,4223659, 312437,\n                                     434490,254761,77074)) %&gt;% \n  group_by(condition_concept_id) %&gt;% \n  count() %&gt;% \n  left_join(cdm$concept,\n            by=c(\"condition_concept_id\" = \"concept_id\")) %&gt;% \n  collect() %&gt;% \n  ggplot() +\n  geom_col(aes(concept_name, n)) +\n  theme_bw()+\n  xlab(\"\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocabulary tables\n\n\n\n\n\nAbove we’ve got counts by specific concept IDs recorded in the condition occurrence table. What these IDs represent is described in the concept table. Here we have the name associate with the concept, along with other information such as it’s domain and vocabulary id.\n\ncdm$concept %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 10\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n$ concept_id       &lt;int&gt; 45756805, 45756804, 45756803, 45756802, 45756801, 457…\n$ concept_name     &lt;chr&gt; \"Pediatric Cardiology\", \"Pediatric Anesthesiology\", \"…\n$ domain_id        &lt;chr&gt; \"Provider\", \"Provider\", \"Provider\", \"Provider\", \"Prov…\n$ vocabulary_id    &lt;chr&gt; \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS\", \"ABMS…\n$ concept_class_id &lt;chr&gt; \"Physician Specialty\", \"Physician Specialty\", \"Physic…\n$ standard_concept &lt;chr&gt; \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\", \"S\"…\n$ concept_code     &lt;chr&gt; \"OMOP4821938\", \"OMOP4821939\", \"OMOP4821940\", \"OMOP482…\n$ valid_start_date &lt;date&gt; 1970-01-01, 1970-01-01, 1970-01-01, 1970-01-01, 1970…\n$ valid_end_date   &lt;date&gt; 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\n\nOther vocabulary tables capture other information about concepts, such as the direct relationships between concepts (the concept relationship table) and hierarchical relationships between (the concept ancestor table).\n\ncdm$concept_relationship %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 6\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n$ concept_id_1     &lt;int&gt; 35804314, 35804314, 35804314, 35804327, 35804327, 358…\n$ concept_id_2     &lt;int&gt; 912065, 42542145, 42542145, 35803584, 42542145, 42542…\n$ relationship_id  &lt;chr&gt; \"Has modality\", \"Has accepted use\", \"Is current in\", …\n$ valid_start_date &lt;date&gt; 2021-01-26, 2019-08-29, 2019-08-29, 2019-05-27, 2019…\n$ valid_end_date   &lt;date&gt; 2099-12-31, 2099-12-31, 2099-12-31, 2099-12-31, 2099…\n$ invalid_reason   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\ncdm$concept_ancestor %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 4\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n$ ancestor_concept_id      &lt;int&gt; 375415, 727760, 735979, 438112, 529411, 14196…\n$ descendant_concept_id    &lt;int&gt; 4335743, 2056453, 41070383, 36566114, 4326940…\n$ min_levels_of_separation &lt;int&gt; 4, 1, 3, 2, 3, 3, 4, 3, 2, 5, 1, 3, 4, 2, 2, …\n$ max_levels_of_separation &lt;int&gt; 4, 1, 5, 3, 3, 6, 12, 3, 2, 10, 1, 3, 4, 2, 2…\n\n\nMore information on the vocabulary tables (as well as other tables in the OMOP CDM version 5.3) can be found at https://ohdsi.github.io/CommonDataModel/cdm53.html#Vocabulary_Tables.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploring the CDM</span>"
    ]
  },
  {
    "objectID": "ch_3_exploring_the_cdm.html#working-with-dates",
    "href": "ch_3_exploring_the_cdm.html#working-with-dates",
    "title": "3  Exploring the CDM",
    "section": "3.3 Working with dates",
    "text": "3.3 Working with dates\nWhen working with dates, the best supported functions come from the clock package. In particular, the following three functions can allow us to do a lot of the date manipulations we might be interested in:\n\nclock::add_days to add days to a date\nclock::add_years to add years to a date\nclock::date_count_between to get the difference between two dates\n\nFor example\n\nlibrary(clock)\n\n\nAttaching package: 'clock'\n\n\nThe following object is masked from 'package:CDMConnector':\n\n    as_date\n\nlibrary(ggplot2)\n\ncdm$observation_period |&gt; \n  mutate(observation_period_start_plus_30_days = add_days(observation_period_start_date,\n                                                   30L),\n         observation_period_start_date_plus_10_years = add_years(observation_period_start_date,\n                                                   10L)) |&gt; \n  glimpse()\n\nRows: ??\nColumns: 7\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n$ observation_period_id                       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9,…\n$ person_id                                   &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9,…\n$ observation_period_start_date               &lt;date&gt; 2014-05-09, 1977-04-11, 2…\n$ observation_period_end_date                 &lt;date&gt; 2023-05-12, 1986-09-15, 2…\n$ period_type_concept_id                      &lt;int&gt; 44814724, 44814724, 448147…\n$ observation_period_start_plus_30_days       &lt;dttm&gt; 2014-06-08, 1977-05-11, 2…\n$ observation_period_start_date_plus_10_years &lt;dttm&gt; 2024-05-09, 1987-04-11, 2…\n\ncdm$observation_period |&gt; \n  dplyr::mutate(observation_days = date_count_between(\"observation_period_start_date\", \n                             \"observation_period_end_date\", \"day\"))  |&gt; \n  dplyr::mutate(observation_years = observation_days/ 365.25) |&gt; \n  collect() %&gt;% \n  ggplot() +\n  geom_histogram(aes(observation_years), \n                 binwidth=2, colour=\"grey\") +\n  theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploring the CDM</span>"
    ]
  },
  {
    "objectID": "ch_3_exploring_the_cdm.html#statistical-summaries",
    "href": "ch_3_exploring_the_cdm.html#statistical-summaries",
    "title": "3  Exploring the CDM",
    "section": "3.4 Statistical summaries",
    "text": "3.4 Statistical summaries\nWe can also use summarise for various other calculations\n\ncdm$person %&gt;% \n  summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q05_year_of_birth = quantile(year_of_birth, 0.05, na.rm=TRUE),\n            mean_year_of_birth = round(mean(year_of_birth, na.rm=TRUE),0),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q95_year_of_birth = quantile(year_of_birth, 0.95, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %&gt;%  \n  glimpse()\n\nRows: ??\nColumns: 6\nDatabase: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\Rtmp2VsoWf\\fileb90678c661f.duckdb]\n$ min_year_of_birth    &lt;int&gt; 1923\n$ q05_year_of_birth    &lt;dbl&gt; 1927\n$ mean_year_of_birth   &lt;dbl&gt; 1971\n$ median_year_of_birth &lt;dbl&gt; 1970\n$ q95_year_of_birth    &lt;dbl&gt; 2018\n$ max_year_of_birth    &lt;int&gt; 2023\n\n\n\n\n\n\n\n\nPiping and SQL\n\n\n\n\n\nAlthough piping queries has little impact on performance when using R with data in memory, when working with a database the SQL generated will differ when using multiple function calls (with a separate operation specified in each) instead of multiple operations within a single function call.\nFor example, a single mutate function above would generate the below SQL.\n\ncdm$observation_period |&gt; \n  mutate(observation_period_start_plus_30_days = add_days(observation_period_start_date,\n                                                   30L),\n         observation_period_start_date_plus_10_years = add_years(observation_period_start_date,\n                                                   10L)) |&gt; \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_period_start_plus_30_days\",\n         \"observation_period_start_date_plus_10_years\") %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  observation_period_id,\n  person_id,\n  DATE_ADD(observation_period_start_date, INTERVAL '30 day') AS observation_period_start_plus_30_days,\n  DATE_ADD(observation_period_start_date, INTERVAL '10 year') AS observation_period_start_date_plus_10_years\nFROM main.observation_period\n\n\nWhereas the SQL will be different if using multiple mutate calls (now using a sub-query).\n\ncdm$observation_period |&gt; \n  mutate(observation_period_start_plus_30_days = add_days(observation_period_start_date,\n                                                   30L)) |&gt; \n  mutate(observation_period_start_date_plus_10_years = add_years(observation_period_start_date,\n                                                   10L)) |&gt; \n  select(\"observation_period_id\", \"person_id\", \n         \"observation_period_start_plus_30_days\",\n         \"observation_period_start_date_plus_10_years\") %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  observation_period_id,\n  person_id,\n  observation_period_start_plus_30_days,\n  DATE_ADD(observation_period_start_date, INTERVAL '10 year') AS observation_period_start_date_plus_10_years\nFROM (\n  SELECT\n    observation_period.*,\n    DATE_ADD(observation_period_start_date, INTERVAL '30 day') AS observation_period_start_plus_30_days\n  FROM main.observation_period\n) q01\n\n\n\n\n\nAs we’ve seen before, we can also quickly get results for various groupings or restrictions\n\ncdm$person %&gt;% \n   group_by(gender_concept_id) %&gt;% \n   summarise(min_year_of_birth = min(year_of_birth, na.rm=TRUE),\n            q25_year_of_birth = quantile(year_of_birth, 0.25, na.rm=TRUE),\n            median_year_of_birth = median(year_of_birth, na.rm=TRUE),\n            q75_year_of_birth = quantile(year_of_birth, 0.75, na.rm=TRUE),\n            max_year_of_birth = max(year_of_birth, na.rm=TRUE)) %&gt;% \n  left_join(cdm$concept, \n            by=c(\"gender_concept_id\" = \"concept_id\")) %&gt;% \n   collect() %&gt;% \n  ggplot(aes(x = concept_name, group = concept_name,\n             fill = concept_name)) +\n  geom_boxplot(aes(\n    lower = q25_year_of_birth, \n    upper = q75_year_of_birth, \n    middle = median_year_of_birth, \n    ymin = min_year_of_birth, \n    ymax = max_year_of_birth),\n    stat = \"identity\", width = 0.5) + \n  theme_bw()+ \n  theme(legend.position = \"none\") +\n  xlab(\"\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Exploring the CDM</span>"
    ]
  },
  {
    "objectID": "ch_4_adding_features.html",
    "href": "ch_4_adding_features.html",
    "title": "4  Identifying patient characteristics",
    "section": "",
    "text": "4.1 Adding specific demographics\nThe PatientProfiles package makes it easy for us to add demographic information to tables in the OMOP CDM. Like the CDMConnector package we’ve seen previously, the fact that the structure of the OMOP CDM is known allows the PatientProfiles package to abstract away some common data manipulations required to do research with patient-level data.2\nLet’s say we are interested in individuals age and sex at time of diagnosis with COVID-19. We can add these variables to the table like so (noting that because age is time-varying, we have to specify the variable with the date for which we want to calculate age relative to).\ncdm$condition_occurrence &lt;- cdm$condition_occurrence %&gt;% \n  addSex() %&gt;% \n  addAge(indexDate = \"condition_start_date\")\n\nWarning: The following columns will be overwritten: provider_id\n\ncdm$condition_occurrence %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 18\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ condition_occurrence_id       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ person_id                     &lt;int&gt; 2, 6, 7, 8, 8, 8, 8, 16, 16, 18, 18, 25,…\n$ condition_concept_id          &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_start_date          &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_start_datetime      &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_date            &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_datetime        &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_type_concept_id     &lt;int&gt; 38000175, 38000175, 38000175, 38000175, …\n$ condition_status_concept_id   &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ stop_reason                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ provider_id                   &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ visit_occurrence_id           &lt;int&gt; 19, 55, 67, 79, 79, 79, 79, 168, 171, 19…\n$ visit_detail_id               &lt;int&gt; 1000019, 1000055, 1000067, 1000079, 1000…\n$ condition_source_value        &lt;chr&gt; \"230690007\", \"410429000\", \"230690007\", \"…\n$ condition_source_concept_id   &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_status_source_value &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sex                           &lt;chr&gt; \"Female\", \"Male\", \"Male\", \"Male\", \"Male\"…\n$ age                           &lt;dbl&gt; 57, 25, 97, 2, 2, 2, 2, 75, 77, 57, 76, …\nWe now have two variables added containing values for age and sex.\ncdm$condition_occurrence %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 18\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ condition_occurrence_id       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ person_id                     &lt;int&gt; 2, 6, 7, 8, 8, 8, 8, 16, 16, 18, 18, 25,…\n$ condition_concept_id          &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_start_date          &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_start_datetime      &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_date            &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_datetime        &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_type_concept_id     &lt;int&gt; 38000175, 38000175, 38000175, 38000175, …\n$ condition_status_concept_id   &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ stop_reason                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ provider_id                   &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ visit_occurrence_id           &lt;int&gt; 19, 55, 67, 79, 79, 79, 79, 168, 171, 19…\n$ visit_detail_id               &lt;int&gt; 1000019, 1000055, 1000067, 1000079, 1000…\n$ condition_source_value        &lt;chr&gt; \"230690007\", \"410429000\", \"230690007\", \"…\n$ condition_source_concept_id   &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_status_source_value &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sex                           &lt;chr&gt; \"Female\", \"Male\", \"Male\", \"Male\", \"Male\"…\n$ age                           &lt;dbl&gt; 57, 25, 97, 2, 2, 2, 2, 75, 77, 57, 76, …\nAnd with these now added it is straightforward to calculate mean age at condition start date by sex or even plot the distribution of age at diagnosis by sex.\ncdm$condition_occurrence %&gt;%\n  summarise(mean_age = mean(age, na.rm=TRUE), .by = \"sex\") %&gt;% \n  collect()\n\n# A tibble: 2 × 2\n  sex    mean_age\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Female     50.8\n2 Male       56.5\ncdm$condition_occurrence %&gt;%\n  select(\"person_id\", \"age\", \"sex\") %&gt;% \n  collect()  %&gt;%\n  ggplot(aes(fill = sex)) +\n  facet_grid(sex ~ .) +\n  geom_histogram(aes(age), colour = \"black\", binwidth = 5) +\n  theme_bw() +\n  theme(legend.position = \"none\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Identifying patient characteristics</span>"
    ]
  },
  {
    "objectID": "ch_4_adding_features.html#adding-specific-demographics",
    "href": "ch_4_adding_features.html#adding-specific-demographics",
    "title": "4  Identifying patient characteristics",
    "section": "4.1 Adding specific demographics",
    "text": "4.1 Adding specific demographics\nThe PatientProfiles package makes it easy for us to add demographic information to tables in the OMOP CDM. Like the CDMConnector package we’ve seen previously, the fact that the structure of the OMOP CDM is known allows the PatientProfiles package to abstract away some common data manipulations required to do research with patient-level data.2\nLet’s say we are interested in individuals age and sex at time of diagnosis with COVID-19. We can add these variables to the table like so (noting that because age is time-varying, we have to specify the variable with the date for which we want to calculate age relative to).\n\ncdm$condition_occurrence &lt;- cdm$condition_occurrence %&gt;% \n  addSex() %&gt;% \n  addAge(indexDate = \"condition_start_date\")\n\nWarning: The following columns will be overwritten: provider_id\n\ncdm$condition_occurrence %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 18\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ condition_occurrence_id       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ person_id                     &lt;int&gt; 2, 6, 7, 8, 8, 8, 8, 16, 16, 18, 18, 25,…\n$ condition_concept_id          &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_start_date          &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_start_datetime      &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_date            &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_datetime        &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_type_concept_id     &lt;int&gt; 38000175, 38000175, 38000175, 38000175, …\n$ condition_status_concept_id   &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ stop_reason                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ provider_id                   &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ visit_occurrence_id           &lt;int&gt; 19, 55, 67, 79, 79, 79, 79, 168, 171, 19…\n$ visit_detail_id               &lt;int&gt; 1000019, 1000055, 1000067, 1000079, 1000…\n$ condition_source_value        &lt;chr&gt; \"230690007\", \"410429000\", \"230690007\", \"…\n$ condition_source_concept_id   &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_status_source_value &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sex                           &lt;chr&gt; \"Female\", \"Male\", \"Male\", \"Male\", \"Male\"…\n$ age                           &lt;dbl&gt; 57, 25, 97, 2, 2, 2, 2, 75, 77, 57, 76, …\n\n\nWe now have two variables added containing values for age and sex.\n\ncdm$condition_occurrence %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 18\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ condition_occurrence_id       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ person_id                     &lt;int&gt; 2, 6, 7, 8, 8, 8, 8, 16, 16, 18, 18, 25,…\n$ condition_concept_id          &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_start_date          &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_start_datetime      &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_date            &lt;date&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_end_datetime        &lt;dttm&gt; 1986-09-08, 2021-06-23, 2021-04-07, 202…\n$ condition_type_concept_id     &lt;int&gt; 38000175, 38000175, 38000175, 38000175, …\n$ condition_status_concept_id   &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ stop_reason                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ provider_id                   &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ visit_occurrence_id           &lt;int&gt; 19, 55, 67, 79, 79, 79, 79, 168, 171, 19…\n$ visit_detail_id               &lt;int&gt; 1000019, 1000055, 1000067, 1000079, 1000…\n$ condition_source_value        &lt;chr&gt; \"230690007\", \"410429000\", \"230690007\", \"…\n$ condition_source_concept_id   &lt;int&gt; 381316, 321042, 381316, 37311061, 437663…\n$ condition_status_source_value &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ sex                           &lt;chr&gt; \"Female\", \"Male\", \"Male\", \"Male\", \"Male\"…\n$ age                           &lt;dbl&gt; 57, 25, 97, 2, 2, 2, 2, 75, 77, 57, 76, …\n\n\nAnd with these now added it is straightforward to calculate mean age at condition start date by sex or even plot the distribution of age at diagnosis by sex.\n\ncdm$condition_occurrence %&gt;%\n  summarise(mean_age = mean(age, na.rm=TRUE), .by = \"sex\") %&gt;% \n  collect()\n\n# A tibble: 2 × 2\n  sex    mean_age\n  &lt;chr&gt;     &lt;dbl&gt;\n1 Female     50.8\n2 Male       56.5\n\n\n\ncdm$condition_occurrence %&gt;%\n  select(\"person_id\", \"age\", \"sex\") %&gt;% \n  collect()  %&gt;%\n  ggplot(aes(fill = sex)) +\n  facet_grid(sex ~ .) +\n  geom_histogram(aes(age), colour = \"black\", binwidth = 5) +\n  theme_bw() +\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "ch_4_adding_features.html#adding-multiple-demographics-simultaneously",
    "href": "ch_4_adding_features.html#adding-multiple-demographics-simultaneously",
    "title": "4  Identifying patient characteristics",
    "section": "4.2 Adding multiple demographics simultaneously",
    "text": "4.2 Adding multiple demographics simultaneously\nWe’ve now seen individual functions from PatientProfiles to add age and sex, and the package has others to add other characteristics like days of prior observation in the database (rather unimaginatively named PatientProfiles::addPriorObservation()). In additional to these individuals functions, the package also provides a more general function to get all of these characteristics at the same time.3\n\ncdm$drug_exposure &lt;- cdm$drug_exposure %&gt;% \n  addDemographics(indexDate = \"drug_exposure_start_date\")\n\nWarning: The following columns will be overwritten: provider_id\n\ncdm$drug_exposure %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 27\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ drug_exposure_id             &lt;int&gt; 245761, 245762, 245763, 245764, 245765, 2…\n$ person_id                    &lt;int&gt; 7764, 7764, 7764, 7764, 7764, 7764, 7764,…\n$ drug_concept_id              &lt;int&gt; 40213227, 40213201, 40213198, 40213154, 4…\n$ drug_exposure_start_date     &lt;date&gt; 2015-02-08, 2010-01-10, 2010-01-10, 2017…\n$ drug_exposure_start_datetime &lt;dttm&gt; 2015-02-08 22:40:04, 2010-01-10 22:40:04…\n$ drug_exposure_end_date       &lt;date&gt; 2015-02-08, 2010-01-10, 2010-01-10, 2017…\n$ drug_exposure_end_datetime   &lt;dttm&gt; 2015-02-08 22:40:04, 2010-01-10 22:40:04…\n$ verbatim_end_date            &lt;date&gt; 2015-02-08, 2010-01-10, 2010-01-10, 2017…\n$ drug_type_concept_id         &lt;int&gt; 32869, 32869, 32869, 32869, 32869, 32869,…\n$ stop_reason                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ refills                      &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ quantity                     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ days_supply                  &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ sig                          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ route_concept_id             &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ lot_number                   &lt;chr&gt; \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"…\n$ provider_id                  &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ visit_occurrence_id          &lt;int&gt; 80896, 80891, 80891, 80892, 80895, 80896,…\n$ visit_detail_id              &lt;int&gt; 1080896, 1080891, 1080891, 1080892, 10808…\n$ drug_source_value            &lt;chr&gt; \"113\", \"33\", \"133\", \"140\", \"140\", \"140\", …\n$ drug_source_concept_id       &lt;int&gt; 40213227, 40213201, 40213198, 40213154, 4…\n$ route_source_value           &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ dose_unit_source_value       &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ age                          &lt;dbl&gt; 71, 66, 66, 73, 72, 71, 69, 67, 70, 68, 6…\n$ sex                          &lt;chr&gt; \"Male\", \"Male\", \"Male\", \"Male\", \"Male\", \"…\n$ prior_observation            &lt;dbl&gt; 2597, 742, 742, 3339, 2968, 2597, 1855, 1…\n$ future_observation           &lt;dbl&gt; 896, 2751, 2751, 154, 525, 896, 1638, 238…\n\n\nWith these characteristics now all added, we can now calculate mean age, prior observation (how many days have passed since the individual’s most recent observation start date), and future observation (how many days until the individual’s nearest observation end date) at drug exposure start date by sex.\n\ncdm$drug_exposure %&gt;%\n  summarise(mean_age = mean(age, na.rm=TRUE),\n            mean_prior_observation = mean(prior_observation, na.rm=TRUE),\n            mean_future_observation = mean(future_observation, na.rm=TRUE),\n            .by = \"sex\") %&gt;% \n  collect()\n\n# A tibble: 2 × 4\n  sex    mean_age mean_prior_observation mean_future_observation\n  &lt;chr&gt;     &lt;dbl&gt;                  &lt;dbl&gt;                   &lt;dbl&gt;\n1 Male       43.0                  2455.                   1768.\n2 Female     39.4                  2096.                   1661.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Identifying patient characteristics</span>"
    ]
  },
  {
    "objectID": "ch_4_adding_features.html#creating-categories",
    "href": "ch_4_adding_features.html#creating-categories",
    "title": "4  Identifying patient characteristics",
    "section": "4.3 Creating categories",
    "text": "4.3 Creating categories\nWhen we add age, either via addAge or addDemographics, we can also add another variable containing age groups. These age groups are specified in a list of vectors, each of which contain the lower and upper bounds.\n\ncdm$visit_occurrence &lt;- cdm$visit_occurrence %&gt;%\n  addAge(indexDate = \"visit_start_date\",\n    ageGroup = list(c(0,17), c(18, 64),\n                    c(65, 150)))\n\nWarning: The following columns will be overwritten: provider_id, care_site_id\n\ncdm$visit_occurrence %&gt;% \n  filter(age &gt;= 0 & age &lt;= 150) %&gt;% \n  group_by(age_group) %&gt;% \n  tally() %&gt;% \n  collect() %&gt;% \n  ggplot() + \n  geom_col(aes(x = age_group, y = n)) + \n  theme_bw()\n\n\n\n\n\n\n\n\nPatientProfiles also provides a more general function for adding categories. Can you guess it’s name? That’s right, we have PatientProfiles::addCategories() for this.\n\ncdm$condition_occurrence %&gt;%\n  addPriorObservation(indexDate = \"condition_start_date\") %&gt;%\n  addCategories(\n    variable = \"prior_observation\",\n    categories = list(\"prior_observation_group\" = list(\n      c(0, 364), c(365, Inf)  \n    ))\n  )\n\n# Source:   table&lt;dbplyr_007&gt; [?? x 20]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n   condition_occurrence_id person_id condition_concept_id condition_start_date\n                     &lt;int&gt;     &lt;int&gt;                &lt;int&gt; &lt;date&gt;              \n 1                       1         2               381316 1986-09-08          \n 2                       2         6               321042 2021-06-23          \n 3                       3         7               381316 2021-04-07          \n 4                       4         8             37311061 2021-01-08          \n 5                       5         8               437663 2021-01-08          \n 6                       6         8              4089228 2021-01-08          \n 7                       7         8               254761 2021-01-08          \n 8                       8        16               381316 2020-02-11          \n 9                       9        16               313217 2021-10-05          \n10                      10        18               317576 1993-08-08          \n# ℹ more rows\n# ℹ 16 more variables: condition_start_datetime &lt;dttm&gt;,\n#   condition_end_date &lt;date&gt;, condition_end_datetime &lt;dttm&gt;,\n#   condition_type_concept_id &lt;int&gt;, condition_status_concept_id &lt;int&gt;,\n#   stop_reason &lt;chr&gt;, provider_id &lt;int&gt;, visit_occurrence_id &lt;int&gt;,\n#   visit_detail_id &lt;int&gt;, condition_source_value &lt;chr&gt;,\n#   condition_source_concept_id &lt;int&gt;, condition_status_source_value &lt;chr&gt;, …",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Identifying patient characteristics</span>"
    ]
  },
  {
    "objectID": "ch_4_adding_features.html#adding-custom-variables",
    "href": "ch_4_adding_features.html#adding-custom-variables",
    "title": "4  Identifying patient characteristics",
    "section": "4.4 Adding custom variables",
    "text": "4.4 Adding custom variables\nWhile PatientProfiles provides a range of functions that can help add characteristics of interest, you may also want to add other, custom features . Obviously we can’t cover here all possible custom characteristics you may wish to add. However, two common groups of custom features are those that are derived from other variables in the same table and others that are taken from other tables and joined to our particular table of interest.\nIn the first case where we want to add a new variable derived from other variables in our table we’ll typically be using dplyr::mutate(). For example, perhaps we just want to add a new variable to our observation period table containing the year of individuals’ observation period start date. This is rather straightforward.\n\ncdm$observation_period &lt;- cdm$observation_period %&gt;% \n  mutate(observation_period_start_year = year(observation_period_start_date))\n\ncdm$observation_period %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 6\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ observation_period_id         &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ person_id                     &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1…\n$ observation_period_start_date &lt;date&gt; 2014-05-09, 1977-04-11, 2014-04-19, 201…\n$ observation_period_end_date   &lt;date&gt; 2023-05-12, 1986-09-15, 2023-04-22, 202…\n$ period_type_concept_id        &lt;int&gt; 44814724, 44814724, 44814724, 44814724, …\n$ observation_period_start_year &lt;dbl&gt; 2014, 1977, 2014, 2014, 2013, 2013, 2013…\n\n\nThe second case is normally more complex task where adding a new variable involves joining to some other table. This table may well have been created by some intermediate query that we wrote to derive the variable of interest. For example, lets say we want to add each number of condition occurrence records for each individual to the person table (remember that we saw how to calculate this in the previous chapter). Here we’ll also create this as a new table containing just the information we’re interested in and compute to a temporary table.\n\ncondition_summary &lt;- cdm$person %&gt;% \n  left_join(cdm$condition_occurrence %&gt;% \n  group_by(person_id) %&gt;% \n  count(name = \"condition_occurrence_records\"),\n  by=\"person_id\") %&gt;% \n  select(\"person_id\", \"condition_occurrence_records\") %&gt;% \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), \n    0, condition_occurrence_records)) %&gt;% \n  compute()\n\ncondition_summary %&gt;% \n  glimpse()\n\nRows: ??\nColumns: 2\nDatabase: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n$ person_id                    &lt;int&gt; 2, 6, 7, 8, 16, 18, 25, 36, 40, 44, 47, 5…\n$ condition_occurrence_records &lt;dbl&gt; 1, 1, 1, 4, 2, 2, 1, 4, 1, 2, 5, 1, 3, 2,…\n\n\nWe can see what goes on behind the scenes by viewing the associated SQL.\n\ncdm$person %&gt;% \n  left_join(cdm$condition_occurrence %&gt;% \n  group_by(person_id) %&gt;% \n  count(name = \"condition_occurrence_records\"),\n  by=\"person_id\") %&gt;% \n  select(\"person_id\", \"condition_occurrence_records\") %&gt;% \n  mutate(condition_occurrence_records = if_else(\n    is.na(condition_occurrence_records), \n    0, condition_occurrence_records)) %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  person_id,\n  CASE WHEN ((condition_occurrence_records IS NULL)) THEN 0.0 WHEN NOT ((condition_occurrence_records IS NULL)) THEN condition_occurrence_records END AS condition_occurrence_records\nFROM (\n  SELECT person.person_id AS person_id, condition_occurrence_records\n  FROM main.person\n  LEFT JOIN (\n    SELECT person_id, COUNT(*) AS condition_occurrence_records\n    FROM dbplyr_002\n    GROUP BY person_id\n  ) RHS\n    ON (person.person_id = RHS.person_id)\n) q01\n\n\n\n\n\n\n\n\nTaking care with joins\n\n\n\n\n\nWhen adding variables through joins we need to pay particular attention to the dimensions of the resulting table. While sometimes we may want to have additional rows added as well as new columns, this is often not desired. If we, for example, have a table with one row per person then a left join to a table with multiple rows per person can then result in a table with multiple rows per person.\nExamples where to be careful include when joining to the observation period table, as individuals can have multiple observation periods, and when working with cohorts (which are the focus of the next chapter) as individuals can also enter the same study cohort multiple times.\nJust to underline how problematic joins can become if we don’t take care, here we join the condition occurrence table and the drug exposure table both of which have multiple records per person. Remember this is just with our small synthetic data, so when working with real patient data which is oftentimes much, much larger this would be extremely problematic (and would unlikely be needed to answer any research question). In other words, don’t try this at home!\n\ncdm$condition_occurrence %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n      n\n  &lt;dbl&gt;\n1  9967\n\ncdm$drug_exposure %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n       n\n   &lt;dbl&gt;\n1 337509\n\ncdm$condition_occurrence %&gt;% \n  select(person_id, condition_start_date) %&gt;% \n  left_join(cdm$drug_exposure %&gt;% \n  select(person_id, drug_exposure_start_date), \n  by = \"person_id\") %&gt;% \n  tally()\n\n# Source:   SQL [1 x 1]\n# Database: DuckDB 0.8.1 [eburn@Windows 10 x64:R 4.2.1/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpyuN850\\file1e3c1a7b608.duckdb]\n       n\n   &lt;dbl&gt;\n1 410683",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Identifying patient characteristics</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html",
    "href": "ch_5_creating_cohorts.html",
    "title": "5  Adding cohorts to the CDM",
    "section": "",
    "text": "5.1 What is a cohort?\nWhen performing research with the OMOP common data model we often want to identify groups of individuals who share some set of characteristics. The criteria for including individuals can range from the seemingly simple (e.g. people diagnosed with asthma) to the much more complicated (e.g. adults diagnosed with asthma who had a year of prior observation time in the database prior to their diagnosis, had no prior history of chronic obstructive pulmonary disease, and no history of use of short-acting beta-antagonists).\nThe set of people we identify are cohorts, and the OMOP CDM has a specific structure by which they can be represented, with a cohort table having four required fields: 1) cohort definition id (a unique identifier for each cohort), 2) subject id (a foreign key to the subject in the cohort - typically referring to records in the person table), 3) cohort start date, and 4) cohort end date. Individuals can enter a cohort multiple times, but the time in which they are in the cohort cannot overlap.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#set-up",
    "href": "ch_5_creating_cohorts.html#set-up",
    "title": "5  Adding cohorts to the CDM",
    "section": "5.2 Set up",
    "text": "5.2 Set up\n\nlibrary(CDMConnector)\nlibrary(CodelistGenerator)\nlibrary(CohortConstructor)\nlibrary(CohortCharacteristics)\nlibrary(dplyr)\n        \ndb &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())\n\ncdm &lt;- cdm_from_con(\n  con = db,\n  cdm_schema = \"main\",\n  write_schema = \"main\"\n)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#creating-a-base-cohort",
    "href": "ch_5_creating_cohorts.html#creating-a-base-cohort",
    "title": "5  Adding cohorts to the CDM",
    "section": "5.3 Creating a base cohort",
    "text": "5.3 Creating a base cohort\nWe can create a set of base cohorts using a code lists or concept set\n\n5.3.1 General concept based cohort\n\ncdm$gi_bleed &lt;- conceptCohort(cdm = cdm, \n                     conceptSet = list(\"gi_bleed\" = 192671), \n                     name = \"gi_bleed\")\ncdm$gi_bleed\n\n# Source:   table&lt;main.gi_bleed&gt; [?? x 4]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpGi5nHI\\file485c26057603.duckdb]\n   cohort_definition_id subject_id cohort_start_date cohort_end_date\n                  &lt;int&gt;      &lt;int&gt; &lt;date&gt;            &lt;date&gt;         \n 1                    1        582 2005-04-04        2005-04-04     \n 2                    1        202 1982-05-16        1982-05-16     \n 3                    1       1571 1998-08-27        1998-08-27     \n 4                    1       2906 1965-07-06        1965-07-06     \n 5                    1       3436 2003-05-03        2003-05-03     \n 6                    1       3961 2011-11-24        2011-11-24     \n 7                    1        160 2006-02-19        2006-02-19     \n 8                    1        693 1995-09-01        1995-09-01     \n 9                    1       1464 2002-11-01        2002-11-01     \n10                    1       3483 1989-01-07        1989-01-07     \n# ℹ more rows\n\n\n\n\n5.3.2 Demographic cohorts\n\ncdm$age_cohorts &lt;- demographicsCohort(cdm = cdm, \n                                      ageRange = list(c(0, 17),\n                                                     c(18, 64),\n                                                     c(65, Inf)), \n                                      name = \"age_cohorts\")\ncdm$age_cohorts\n\n# Source:   SQL [?? x 4]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpGi5nHI\\file485c26057603.duckdb]\n   cohort_definition_id subject_id cohort_start_date cohort_end_date\n                  &lt;dbl&gt;      &lt;int&gt; &lt;date&gt;            &lt;date&gt;         \n 1                    3         42 1974-11-02        2019-03-13     \n 2                    3          2 1985-06-01        2008-03-25     \n 3                    3         11 2018-02-03        2019-05-07     \n 4                    3         32 2008-10-27        2014-12-24     \n 5                    3         17 2015-12-11        2019-01-07     \n 6                    3          3 1981-01-03        2018-10-29     \n 7                    3         94 2017-03-28        2018-12-28     \n 8                    3         72 2012-07-14        2018-11-12     \n 9                    3         69 2008-10-27        2019-02-06     \n10                    3        116 1991-11-07        2006-07-16     \n# ℹ more rows\n\n\n\n\n\n\n\n\nFinding appropriate codes\n\n\n\n\n\nIn the defining the cohorts above we have needed to provide concept IDs to define our cohort. But, where do these come from?\nWe can search for codes of interest using the CodelistGenerator package. This can be done using a text search with the function CodelistGenerator::getCandidateCodes(). For example, we can find the GI code we use above like so:\n\ngetCandidateCodes(cdm = cdm, \n                  keywords = \"Gastrointestinal hemorrhage\",\n                  domains = \"condition\",\n                  includeDescendants = TRUE)\n\nLimiting to domains of interest\nGetting concepts to include\nAdding descendants\nSearch completed. Finishing up.\n✔ 1 candidate concept identified\n\nTime taken: 0 minutes and 0 seconds\n\n\n# A tibble: 1 × 6\n  concept_id found_from    concept_name domain_id vocabulary_id standard_concept\n       &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;        &lt;chr&gt;     &lt;chr&gt;         &lt;chr&gt;           \n1     192671 From initial… Gastrointes… Condition SNOMED        S               \n\n\nWe can also do automated searches that make use of the hierarchies in the vocabularies. Here, for example, we find the code for the drug ingredient Acetaminophen and all of it’s descendants.\n\nCodelistGenerator::getDrugIngredientCodes(cdm = cdm, \n                                          name = \"acetaminophen\")\n\n\n\n\n── 1 codelist ──────────────────────────────────────────────────────────────────\n\n\n\n- acetaminophen (7 codes)\n\n\nNote that the data we’re using just has a subset of the full OMOP CDM vocabularies. In practice, these searches would return many more codes. And in the case of the former in particular, clinical expertise would then be required to decide which of the codes were in line with the clinical idea at hand.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#cohort-attributes",
    "href": "ch_5_creating_cohorts.html#cohort-attributes",
    "title": "5  Adding cohorts to the CDM",
    "section": "5.4 Cohort attributes",
    "text": "5.4 Cohort attributes\nThe set of cohorts we create will be associated with various attributes. The cohort set attribute contains information on the cohorts that we’ve generated.\n\nsettings(cdm$gi_bleed) %&gt;% \n  glimpse()\n\nRows: 1\nColumns: 2\n$ cohort_definition_id &lt;int&gt; 1\n$ cohort_name          &lt;chr&gt; \"gi_bleed\"\n\n\nAnother attribute contains counts of the cohorts we’ve created.\n\ncohortCount(cdm$gi_bleed) %&gt;% \n  glimpse()\n\nRows: 1\nColumns: 3\n$ cohort_definition_id &lt;int&gt; 1\n$ number_records       &lt;int&gt; 479\n$ number_subjects      &lt;int&gt; 479\n\n\nAnd we can also see attrition related to the cohort. We’ll see below how any addition inclusion criteria that we apply can be recorded using this attrition attribute.\n\nattrition(cdm$gi_bleed) %&gt;% \n  glimpse()\n\nRows: 1\nColumns: 7\n$ cohort_definition_id &lt;int&gt; 1\n$ number_records       &lt;int&gt; 479\n$ number_subjects      &lt;int&gt; 479\n$ reason_id            &lt;int&gt; 1\n$ reason               &lt;chr&gt; \"Initial qualifying events\"\n$ excluded_records     &lt;int&gt; 0\n$ excluded_subjects    &lt;int&gt; 0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#applying-inclusion-criteria",
    "href": "ch_5_creating_cohorts.html#applying-inclusion-criteria",
    "title": "5  Adding cohorts to the CDM",
    "section": "5.5 Applying inclusion criteria",
    "text": "5.5 Applying inclusion criteria\n\n5.5.1 Restrict to study period\n\ncdm$gi_bleed &lt;- cdm$gi_bleed %&gt;%\n   requireInDateRange(dateRange = c(as.Date(\"1990-01-01\"), NA))\n\n\n\n5.5.2 Only include first cohort entry per person\n\ncdm$gi_bleed &lt;- cdm$gi_bleed %&gt;% \n     requireIsFirstEntry() \n\n\n\n5.5.3 Applying demographic inclusion criteria\nSay for our study we want to include people with a GI bleed who were aged 40 or over at the time. We can use the add variables with these characteristics as seen in chapter 4 and then filter accordingly. The function CDMConnector::record_cohort_attrition() will then update our cohort attributes as we can see below.\n\ncdm$gi_bleed &lt;- cdm$gi_bleed %&gt;%\n   requireDemographics(ageRange = c(18, 64), sex = \"Male\")\n\n\ncohortCount(cdm$gi_bleed)\n\n# A tibble: 1 × 3\n  cohort_definition_id number_records number_subjects\n                 &lt;int&gt;          &lt;int&gt;           &lt;int&gt;\n1                    1            177             177\n\nsettings(cdm$gi_bleed)\n\n# A tibble: 1 × 6\n  cohort_definition_id cohort_name age_range sex   min_prior_observation\n                 &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt;\n1                    1 gi_bleed    18_64     Male                      0\n# ℹ 1 more variable: min_future_observation &lt;dbl&gt;\n\n\n\n\n5.5.4 Applying cohort-based inclusion criteria\nAs well as requirements about specific demographics, we may also want to use another cohort for inclusion criteria. Let’s say we want to exclude anyone with rheumatoid arthritis diagnosed before their GI bleed. We can first generate this cohort and then apply this additional exclusion criteria like so.\n\ncdm$acetaminophen &lt;- conceptCohort(\n  cdm = cdm,\n  list(\"acetaminophen\" = c(\n    1125315,\n    1127078,\n    1127433,\n    40229134,\n    40231925,\n    40162522,\n    19133768\n  )), \nname = \"acetaminophen\"\n)\ncdm$acetaminophen\n\n# Source:   table&lt;main.acetaminophen&gt; [?? x 4]\n# Database: DuckDB v1.0.0 [eburn@Windows 10 x64:R 4.4.0/C:\\Users\\eburn\\AppData\\Local\\Temp\\RtmpGi5nHI\\file485c26057603.duckdb]\n   cohort_definition_id subject_id cohort_start_date cohort_end_date\n                  &lt;int&gt;      &lt;int&gt; &lt;date&gt;            &lt;date&gt;         \n 1                    1        624 1961-11-07        1961-11-14     \n 2                    1        665 2011-08-23        2011-09-06     \n 3                    1       2013 1956-10-13        1956-10-27     \n 4                    1       2189 2004-04-08        2004-04-22     \n 5                    1       2218 1980-12-08        1980-12-22     \n 6                    1       3236 1940-04-17        1940-05-01     \n 7                    1         32 2003-07-09        2003-07-23     \n 8                    1        479 1957-04-13        1957-04-27     \n 9                    1       1053 1989-01-21        1989-02-18     \n10                    1       1861 2015-05-05        2015-05-19     \n# ℹ more rows\n\n\n\ncdm$gi_bleed &lt;- cdm$gi_bleed %&gt;% \n  requireCohortIntersect(targetCohortTable = \"acetaminophen\", \n                         indexDate = \"cohort_start_date\", \n                         window = c(-Inf, -1)) \n\n\ncohortCount(cdm$gi_bleed)\n\n# A tibble: 1 × 3\n  cohort_definition_id number_records number_subjects\n                 &lt;int&gt;          &lt;int&gt;           &lt;int&gt;\n1                    1            175             175\n\nattrition(cdm$gi_bleed)\n\n# A tibble: 8 × 7\n  cohort_definition_id number_records number_subjects reason_id reason          \n                 &lt;int&gt;          &lt;int&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;           \n1                    1            479             479         1 Initial qualify…\n2                    1            349             349         2 cohort_start_da…\n3                    1            349             349         3 Restricted to f…\n4                    1            349             349         4 Age requirement…\n5                    1            177             177         5 Sex requirement…\n6                    1            177             177         6 Prior observati…\n7                    1            177             177         7 Future observat…\n8                    1            175             175         8 In cohort aceta…\n# ℹ 2 more variables: excluded_records &lt;int&gt;, excluded_subjects &lt;int&gt;",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#creating-multiple-derived-cohorts",
    "href": "ch_5_creating_cohorts.html#creating-multiple-derived-cohorts",
    "title": "5  Adding cohorts to the CDM",
    "section": "6.1 Creating multiple derived cohorts",
    "text": "6.1 Creating multiple derived cohorts\nTO BE DONE",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding cohorts to the CDM</span>"
    ]
  },
  {
    "objectID": "ch_6_working_with_cohorts.html",
    "href": "ch_6_working_with_cohorts.html",
    "title": "6  Working with cohorts",
    "section": "",
    "text": "6.1 Cohort intersections\nPatientProfiles::addCohortIntersect()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Working with cohorts</span>"
    ]
  },
  {
    "objectID": "ch_6_working_with_cohorts.html#intersection-between-two-cohorts",
    "href": "ch_6_working_with_cohorts.html#intersection-between-two-cohorts",
    "title": "6  Working with cohorts",
    "section": "6.2 Intersection between two cohorts",
    "text": "6.2 Intersection between two cohorts",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Working with cohorts</span>"
    ]
  },
  {
    "objectID": "ch_6_working_with_cohorts.html#set-up",
    "href": "ch_6_working_with_cohorts.html#set-up",
    "title": "6  Working with cohorts",
    "section": "6.3 Set up",
    "text": "6.3 Set up\n\nlibrary(CDMConnector)\nlibrary(dplyr)\nlibrary(PatientProfiles)\n        \ndb &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())\n\ncdm &lt;- cdm_from_con(\n  con = db,\n  cdm_schema = \"main\",\n  write_schema = \"main\"\n)\n\ncdm &lt;- cdm %&gt;% \n  generate_concept_cohort_set(concept_set = list(\"gi_bleed\" = 192671), \n                            limit = \"all\", \n                            end = 30,\n                            name = \"gi_bleed\",\n                            overwrite = TRUE) %&gt;% \n  generate_concept_cohort_set(concept_set = list(\"acetaminophen\" = c(1125315,\n                                                              1127078,\n                                                              1127433,\n                                                              40229134,\n                                                              40231925,\n                                                              40162522,\n                                                              19133768)), \n                              limit = \"all\", \n                            # end = \"event_end_date\",\n                            name = \"acetaminophen\",\n                            overwrite = TRUE)\n\n\n6.3.1 Flag\n\ncdm$gi_bleed &lt;- cdm$gi_bleed %&gt;% \n  addCohortIntersectFlag(targetCohortTable = \"acetaminophen\",\n                         window = list(c(-Inf, -1), c(0,0), c(1, Inf)))\n\ncdm$gi_bleed %&gt;% \n  summarise(acetaminophen_prior = sum(acetaminophen_minf_to_m1), \n            acetaminophen_index = sum(acetaminophen_0_to_0),\n            acetaminophen_post = sum(acetaminophen_1_to_inf)) %&gt;% \n  collect()\n\n# A tibble: 1 × 3\n  acetaminophen_prior acetaminophen_index acetaminophen_post\n                &lt;dbl&gt;               &lt;dbl&gt;              &lt;dbl&gt;\n1                 467                 467                476\n\n\n\n\n6.3.2 Count\n\n\n6.3.3 Date and times",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Working with cohorts</span>"
    ]
  },
  {
    "objectID": "ch_6_working_with_cohorts.html#intersection-between-a-cohort-and-tables-with-patient-data",
    "href": "ch_6_working_with_cohorts.html#intersection-between-a-cohort-and-tables-with-patient-data",
    "title": "6  Working with cohorts",
    "section": "6.4 Intersection between a cohort and tables with patient data",
    "text": "6.4 Intersection between a cohort and tables with patient data",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Working with cohorts</span>"
    ]
  },
  {
    "objectID": "ch_7_summarising_cohorts.html",
    "href": "ch_7_summarising_cohorts.html",
    "title": "7  Summarising cohorts",
    "section": "",
    "text": "7.1 Summarising patient demographics\nPatientProfiles::summariseCharacteristics …..",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Summarising cohorts</span>"
    ]
  },
  {
    "objectID": "ch_7_summarising_cohorts.html#large-scale-characterisation",
    "href": "ch_7_summarising_cohorts.html#large-scale-characterisation",
    "title": "7  Summarising cohorts",
    "section": "7.2 Large scale characterisation",
    "text": "7.2 Large scale characterisation\nPatientProfiles::summariseLargeScaleCharacteristics …..\nTO ADD",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Summarising cohorts</span>"
    ]
  },
  {
    "objectID": "ch_1_getting_started.html#a-first-data-analysis-in-r-with-a-database",
    "href": "ch_1_getting_started.html#a-first-data-analysis-in-r-with-a-database",
    "title": "1  Getting started",
    "section": "1.1 A first data analysis in R with a database",
    "text": "1.1 A first data analysis in R with a database\n\nArtwork by @allison_horst\nBefore we start thinking about working with health care data spread across a database using the OMOP common data model, let’s first do a quick data analysis from R using a simpler dataset held in a database. For this we’ll use data from palmerpenguins package, which contains data on penguins collected from the Palmer Station in Antarctica."
  },
  {
    "objectID": "index.html#is-this-book-for-me",
    "href": "index.html#is-this-book-for-me",
    "title": "Tidy R programming with the OMOP common data model",
    "section": "Is this book for me?",
    "text": "Is this book for me?\nWe’ve written this book for anyone interested in a working with databases mapped to the OMOP Common Data Model (CDM) in a tidyverse inspired approach. That is, human centered, consistent, composable, and inclusive (see https://design.tidyverse.org/unifying.html for more details on these principles).\nNew to the OMOP CDM? We’d recommend you pare this book with The Book of OHDSI\nNew to R? We recommend you compliment the book with R for data science"
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "Tidy R programming with the OMOP common data model",
    "section": "Citation",
    "text": "Citation\nTO ADD"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Tidy R programming with the OMOP common data model",
    "section": "License",
    "text": "License\n This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "index.html#code",
    "href": "index.html#code",
    "title": "Tidy R programming with the OMOP common data model",
    "section": "Code",
    "text": "Code\nThe source code for the book can be found at this Github repository"
  },
  {
    "objectID": "ch_2_cdm_reference.html#connecting-to-a-database-from-r-using-dbi",
    "href": "ch_2_cdm_reference.html#connecting-to-a-database-from-r-using-dbi",
    "title": "2  Creating a reference to the OMOP common data model",
    "section": "2.1 Connecting to a database from R using DBI",
    "text": "2.1 Connecting to a database from R using DBI\nDatabase connections from R can be made using the DBI package. The back-end for DBI is facilitated by database specific driver packages. As an example, lets say we want to work with an in-process duckdb database from R. In this case the we can use the duckdb R package as the driver, connecting to a database with the OMOP CDM for a synthetic population of 200,000 people.\n\nlibrary(DBI)\nlibrary(here)\n\n\ndb&lt;-dbConnect(duckdb::duckdb(), \n              dbdir= Sys.getenv(\"DUCKDB\"))\n\nIf we instead wanted to connect to other database management systems, these connections would be supported by the associated back-end packages. For example a connection to a Postgres database would look something like:\n\n# Postgres\ndb &lt;- DBI::dbConnect(RPostgres::Postgres(),\n                      dbname = Sys.getenv(\"CDM5_POSTGRESQL_DBNAME\"),\n                      host = Sys.getenv(\"CDM5_POSTGRESQL_HOST\"),\n                      user = Sys.getenv(\"CDM5_POSTGRESQL_USER\"),\n                      password = Sys.getenv(\"CDM5_POSTGRESQL_PASSWORD\"))"
  },
  {
    "objectID": "ch_4_adding_features.html#footnotes",
    "href": "ch_4_adding_features.html#footnotes",
    "title": "4  Identifying patient characteristics",
    "section": "",
    "text": "In some datasets characteristics that could conceptually be considered as time-varying are encoded as time-invariant. One example for the latter is that in some cases an individual may be associated with a particular socioeconomic status or nationality that for the purposes of the data is treated as time-invariant.↩︎\nAlthough these manipulations can on the face of it seem quite simple, their implementation across different database platforms with different data granularity (for example whether day of birth has been filled in for all patients or not) presents challenges that the PatientProfiles package solves for us.↩︎\nThis function also provides a more time efficient method that getting the characteristics one by one. This is because these characteristics are all derived from the OMOP CDM person and observation period tables and so can be identified simultaneously.↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Identifying patient characteristics</span>"
    ]
  },
  {
    "objectID": "ch_5_creating_cohorts.html#what-is-a-cohort",
    "href": "ch_5_creating_cohorts.html#what-is-a-cohort",
    "title": "5  Adding cohorts to the CDM",
    "section": "5.1 What is a cohort?",
    "text": "5.1 What is a cohort?\nWhen performing research with the OMOP common data model we often want to identify groups of individuals who share some set of characteristics. The criteria for including individuals can range from the seemingly simple (e.g. people diagnosed with asthma) to the much more complicated (e.g. adults diagnosed with asthma who had a year of prior observation time in the database prior to their diagnosis, had no prior history of chronic obstructive pulmonary disease, and no history of use of short-acting beta-antagonists).\nThe set of people we identify are cohorts, and the OMOP CDM has a specific structure by which they can be represented, with a cohort table having four required fields: 1) cohort definition id (a unique identifier for each cohort), 2) subject id (a foreign key to the subject in the cohort - typically referring to records in the person table), 3) cohort start date, and 4) cohort end date. Individuals can enter a cohort multiple times, but the time in which they are in the cohort cannot overlap."
  },
  {
    "objectID": "ch_6_working_with_cohorts.html#cohort-intersections",
    "href": "ch_6_working_with_cohorts.html#cohort-intersections",
    "title": "6  Working with cohorts",
    "section": "6.1 Cohort intersections",
    "text": "6.1 Cohort intersections\nPatientProfiles::addCohortIntersect()"
  },
  {
    "objectID": "ch_7_summarising_cohorts.html#summarising-patient-demographics",
    "href": "ch_7_summarising_cohorts.html#summarising-patient-demographics",
    "title": "7  Summarising cohorts",
    "section": "7.1 Summarising patient demographics",
    "text": "7.1 Summarising patient demographics\nPatientProfiles::summariseCharacteristics ….."
  }
]